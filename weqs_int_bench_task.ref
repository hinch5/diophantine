*$MST_FROM_ENTRY;
*$MATCHING ForRepeatedSpecialization;
*$STRATEGY Applicative;

$ENTRY Go { (e.Rules) = <Eq (e.Rules) <Sim ( ) <Decode (<Conc ('As =') ' Cs'>)>>>;}

/*$ENTRY Go {  = <Print <Eq (('Cs -> As Cs')('Cs -> empty')) <Sim ( ) <Decode (<Conc ('As =') ' Cs'>)>>>>;}*/

/* Auxiliary function concatenating too long input strings.*/
Conc {(e.1) e.2 = e.1 e.2;}

Const__ { e.x = e.x;}

/* Главная функция перекодировки уравнения из пользовательского формата во внутренний формат интерпретатора. */
Decode {
	(e.Left'='e.Right) = (Original (<Translate e.Left>)(<Translate e.Right>));
}

/* Список всех литералов, которые могут выступать в качестве имен переменных. */
Variables {
	= 'QWERTYUIOPASDFGHJKLZXCVBNM';
}

/* Список всех литералов, которые могут выступать в качестве букв алфавита констант. */
Alphabet {
	= 'qwertyuiopasdfghjklzxcvbnm'; 
}

AlphabetT {
	= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
}

IfInSet {
	s.Term (s.Term e.Rest) = 'T';
	s.Term ( ) = 'F';
	s.Term (s.OtherTerm e.Rest) = <IfInSet s.Term (e.Rest)>;
}

IfInSetMultiple {
	(s.Value e.ToSearch) (e.List) = <IfInSetMultiple (e.ToSearch) (e.List) <IfInSet s.Value (e.List)>>;
	(s.Value e.ToSearch) (e.List) 'T' = <IfInSetMultiple (e.ToSearch) (e.List) <IfInSet s.Value (e.List)>>;
	(s.Value e.ToSearch) (e.List) 'F' = 'F';
	() (e.List) 'T' = 'T';
}

/*
раскодирование уравнения
 1. опциональный started
 2. результат (читать список)
 3. был ли текущий терм в списке имен переменных
 4. был ли текущий терм в списке имен констант

 живем ли мы в контексте буквенной переменной
 накопленная инфа о буквенной переменной
 5. множество допустимых имен переменных
 6. множество допустимых имен констант
 7. все остальное
*/
Translate {
	/* закончили */
	/* EMPTY */ = /* EMPTY */;
	/* срезаем пробел слева */
	' 'e.x = <Translate e.x>;
	/* срезаем пробел справа */
	e.x' ' = <Translate e.x>;
	/* окончание буквенной переменной */
	Started (e.Result) 'TFT' (e.variables)(e.alphabet)s.Name s.Name2 s.Name3 s.Name4 s.Name5 't'
		= e.Result (var 't' s.Name s.Name2 s.Name3 s.Name4 s.Name5);
	/* получается, ласт элемент (переменная, не константа) */
	Started (e.Result) 'TFF' (e.variables)(e.alphabet)s.Name's'
		= e.Result (var 'e' s.Name);
	/* получается, ласт элемент (константа) */
	Started (e.Result)'FTF' (e.variables)(e.alphabet)s.Name
		= e.Result s.Name;
	/* закончили буквенную и дальше есть много всего */
	Started (e.Result) 'TFT' (e.variables)(e.alphabet) s.Name s.Name2 s.Name3 s.Name4 s.Name5 't ' s.Next s.Next2 s.Next3 s.Next4 s.Next5 e.Rest
		= <Translate Started (e.Result (var 't' s.Name s.Name2 s.Name3 s.Name4 s.Name5))
			<IfInSet s.Next(e.variables)><IfInSet s.Next(e.alphabet)><IfInSetMultiple (s.Next s.Next2 s.Next3 s.Next4 s.Next5) (e.variables)>
			(e.variables)(e.alphabet) s.Next s.Next2 s.Next3 s.Next4 s.Next5 e.Rest>;
	/* закончили буквенную и дальше есть один символ */
    Started (e.Result) 'TFT' (e.variables)(e.alphabet) s.Name s.Name2 s.Name3 s.Name4 s.Name5 't ' s.Next e.Rest
    	= <Translate Started (e.Result (var 't' s.Name s.Name2 s.Name3 s.Name4 s.Name5))
    		<IfInSet s.Next(e.variables)><IfInSet s.Next(e.alphabet)>'F'
    		(e.variables)(e.alphabet) s.Next e.Rest>;
	/* переменная и дальше есть много всего */
	Started (e.Result)'TFF' (e.variables)(e.alphabet)s.Name's ' s.Next s.Next2 s.Next3 s.Next4 s.Next5 e.Rest
    		= <Translate Started (e.Result (var 'e' s.Name))
    			<IfInSet s.Next(e.variables)><IfInSet s.Next(e.alphabet)><IfInSetMultiple (s.Next s.Next2 s.Next3 s.Next4 s.Next5) (e.variables)>
    			(e.variables)(e.alphabet) s.Next s.Next2 s.Next3 s.Next4 s.Next5 e.Rest>;
	/* переменная и дальше мало всего */
	Started (e.Result)'TFF' (e.variables)(e.alphabet)s.Name's ' s.Next e.Rest
    		= <Translate Started (e.Result (var 'e' s.Name))
    			<IfInSet s.Next(e.variables)><IfInSet s.Next(e.alphabet)>'F'
    			 (e.variables)(e.alphabet) s.Next e.Rest>;
	/* константа и дальше много всего */
	Started (e.Result)'FTF'()(e.variables)(e.alphabet)s.Name' 's.Next s.Next2 s.Next3 s.Next4 s.Next5 e.Rest
		= <Translate Started (e.Result s.Name)
			<IfInSet s.Next(e.variables)><IfInSet s.Next(e.alphabet)><IfInSetMultiple (s.Next s.Next2 s.Next3 s.Next4 s.Next5)(e.variables)>
			(e.variables)(e.alphabet)s.Next s.Next2 s.Next3 s.Next4 s.Next5 e.Rest>;
	/* константа и дальше мало всего */
	Started (e.Result)'FTF' (e.variables)(e.alphabet)s.Name' 's.Next e.Rest
    		= <Translate Started (e.Result s.Name)
    			<IfInSet s.Next(e.variables)><IfInSet s.Next(e.alphabet)>'F'
    			(e.variables)(e.alphabet)s.Next e.Rest>;
	/* получается флаг started не установлен */
	s.Term s.Term2 s.Term3 s.Term4 s.Term5 e.Rest
		= <Translate Started ()
			<IfInSet s.Term(<Variables>)><IfInSet s.Term(<Alphabet>)><IfInSetMultiple (s.Term s.Term2 s.Term3 s.Term4 s.Term5) (<Variables>)>
			(<Variables>)(<Alphabet>) s.Term s.Term2 s.Term3 s.Term4 s.Term5 e.Rest>;
	s.Term e.Rest = <Translate Started ()
		<IfInSet s.Term(<Variables>)><IfInSet s.Term(<Alphabet>)>'F'
		(<Variables>)(<Alphabet>) s.Term e.Rest>;
}

ProcessGeneratedEq {
	((s.Name 's -> empty') e.Rules) (t.Tag ((var 'e' s.Name))()) (e.Processed) = <ProcessGeneratedEq (e.Rules) (t.Tag ()()) (e.Processed)>;
	((s.Name 's -> ' s.Name2 's ' s.Name 's') e.Rules) (t.Tag ((var 'e' s.Name)) ((var 'e' s.Name2) e.Rest)) (e.Processed) = <ProcessGeneratedEq (e.Rules) (t.Tag ((var 'e' s.Name))(e.Rest)) (e.Processed)>;
	((s.Name 's -> ' s.x1 s.x2 s.x3 s.x4 s.x5 't ' s.Name 's') e.Rules) (t.Tag ((var 'e' s.Name)) ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.Rest)) (e.Processed) = <ProcessGeneratedEq (e.Rules) (t.Tag ((var 'e' s.Name))(e.Rest)) (e.Processed)>;
	(e.Rules) (e.Any) (e.Processed) = (e.Rules) (e.Processed (e.Any));
}

ProcessGeneratedRules {
	(e.Rules) (e.Generated) = <ProcessGeneratedRules (e.Rules) () (e.Generated)>;
	(e.Rules) (e.Processed) () = (e.Rules) (e.Processed);
	(e.Rules) (e.Processed) (t.Eq e.Generated) = <ProcessGeneratedRules <ProcessGeneratedEq (e.Rules) t.Eq (e.Processed)> (e.Generated)>;
}

/*совместимость*/
Eq {
	(e.Rules) e.System = <Eq2 (e.Rules) (e.System)>;
}

/*вызов решателя диофантовых уравнений и обработка результат*/
Eq2 {
	(e.Rules) (e.System) = <Eq2 Solved (e.Rules) (<DiophantineSolve (e.System)>)>;
	Solved (e.Rules) False = False;
	Solved (e.Rules) (e.System) = <Eq2 Split (e.Rules) <SplitGenerated (e.System)> >;
	Split (e.Rules) (e.Generated) (e.System) = <Eq2 Processed <ProcessGeneratedRules (e.Rules) (e.Generated)> (e.System)>;
	Processed (e.Rules) (e.Processed) (e.System) = <Eq2 Filled <ProcessTVars (e.Rules) (e.Processed e.System)>>;
	Filled (e.Rules) (e.System) = <EqSubst (e.Rules) e.System>;
}

ProcessTVars {
	(e.Rules) (e.System) = <ProcessTVars (e.Rules) () (e.System)>;
	((s.x1 s.x2 s.x3 s.x4 s.x5't -> 's.Sym'') e.Rules) (e.Processed) ((t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))(s.Sym)) e.System)
		= <ProcessTVars (e.Rules) (e.Processed (t.Tag ()())) (<Sim () <subst_2 (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(s.Sym)) e.System>>)>;
    ((s.x1 s.x2 s.x3 s.x4 s.x5't -> 's.Sym'') e.Rules) (e.Processed) ((t.Tag (s.Sym)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))) e.System)
    	= <ProcessTVars (e.Rules) (e.Processed (t.Tag ()())) (<Sim () <subst_2 (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(s.Sym)) e.System>>)>;
    ((s.x1 s.x2 s.x3 s.x4 s.x5't -> 's.x6 s.x7 s.x8 s.x9 s.x10't') e.Rules) (e.Processed) ((t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))((var 't' s.x6 s.x7 s.x8 s.x9 s.x10))) e.System)
    	= <ProcessTVars (e.Rules) (e.Processed (t.Tag ()())) (<Sim () <subst_2 (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)((var 't' s.x6 s.x7 s.x8 s.x9 s.x10))) e.System>>)>;
	(e.Rules) (e.Processed) (e.System) = (e.Rules) (e.Processed e.System);
}

/*
Функция EqSubst осуществляет развертку системы уравнений согласно заданному пути и имеет входной формат: (#e.Rules)((e.LHS)(e.RHS))e.Equations.
Параметр e.Rules – путь по дереву решений системы уравнений,
  e.LHS и e.RHS – левая и правая части уравнения e.LHS = e.RHS имеют одинаковый синтаксис;
  e.LHS ::= Symbol e.LHS || (var 'e' s.Name) e.LHS || EMPTY
  e.Equations ::= ((e.LHS)(e.RHS)) || EMPTY
*/
EqSubst {
	/* 1а. Если обе части единственного в списке уравнения пусты, получено тривиальное тождество и развертка завершается.
  	Считаем, что список правил, которые нужно применить к этому тождеству, также пуст. */
	(/* EMPTY */) (t.Tag (/*EMPTY*/)(/*EMPTY*/)) = True;
	/* 1б. Если обе части очередного в списке уравнения пусты, переходим к развертке следующего уравнения в списке. */
	(e.Rules) (t.Tag (/*EMPTY*/)(/*EMPTY*/)) e.Other = <EqSubst (e.Rules) e.Other>;
	/* 2а+4a+6a. Какова бы ни была правая часть уравнения, если левая начинается с е-переменной x, и правило преобразования есть x -> empty,
      тогда строим присваивание этой переменной значения, равного пустой строке, и осуществляем подстановку данного присваивания. */
	((s.x's -> empty') e.R1) (t.Tag (e.LHS)((var 'e' s.x) e.RHS)) e.Other
		= <Eq2 (e.R1) (<Sim (/* EMPTY */)
			(t.Tag (<subst (assign (var 'e' s.x)(/* EMPTY */))(/*EMPTY*/)(e.LHS)>)
			(<subst (assign (var 'e' s.x)(/* EMPTY */))(/*EMPTY*/)(e.RHS)>))
			<subst_2 (assign (var 'e' s.x)(/* EMPTY */))e.Other>
		>)>;
	/* 2б+4б+6б. Какова бы ни была левая часть уравнения, если правая начинается с е-переменной x, и правило преобразования есть x -> empty,
      тогда строим присваивание этой переменной значения, равного пустой строке, и осуществляем подстановку данного присваивания. */
	((s.x's -> empty') e.R1) (t.Tag ((var 'e' s.x) e.LHS)(e.RHS)) e.Other
		= <Eq2 (e.R1) (<Sim (/* EMPTY */)
			(t.Tag (<subst (assign (var 'e' s.x)(/* EMPTY */))(/*EMPTY*/)(e.LHS)>)
			(<subst (assign (var 'e' s.x)(/* EMPTY */))(/*EMPTY*/)(e.RHS)>))
			<subst_2 (assign (var 'e' s.x)(/* EMPTY */))e.Other>
		>)>;
	/* 3a. Если левая часть уравнения начинается с e-переменной x, а правая – с буквы s.Sym,
      и правило преобразования есть x -> s.Sym x, осуществляем подстановку x := s.Sym++x.
      После этого вызываем функцию упрощения уравнений (Sim). */
	((s.x's -> 's.Sym' 's.x's') e.R1) (t.Tag ((var 'e' s.x) e.LHS)(s.Sym e.RHS)) e.Other
		= <Eq2 (e.R1) (<Sim (/* EMPTY */)
			(t.Tag (<subst (assign (var 'e' s.x)(s.Sym (var 'e' s.x)))((var 'e' s.x))(e.LHS)>)
			(<subst (assign (var 'e' s.x)(s.Sym (var 'e' s.x)))(/*EMPTY*/)(e.RHS)>))
			<subst_2 (assign (var 'e' s.x)(s.Sym (var 'e' s.x)))e.Other>
		>)>;
	/* 3б. Если правая часть уравнения начинается с e-переменной x, а левая – с буквы s.Sym,
      и правило преобразования есть x -> s.Sym x, осуществляем подстановку x := s.Sym++x.
      После этого вызываем функцию упрощения уравнений (Sim). */
	((s.x's -> 's.Sym' 's.x's') e.R1) (t.Tag (s.Sym e.LHS)((var 'e' s.x) e.RHS)) e.Other
		= <Eq2 (e.R1) (<Sim (/* EMPTY */)
			(t.Tag (<subst (assign (var 'e' s.x)(s.Sym (var 'e' s.x)))(/*EMPTY*/)(e.LHS)>)
			(<subst (assign (var 'e' s.x)(s.Sym (var 'e' s.x)))((var 'e' s.x))(e.RHS)>))
			<subst_2 (assign (var 'e' s.x)(s.Sym (var 'e' s.x)))e.Other>
		>)>;
	/* 5a. Если левая часть уравнения начинается с переменной x, а правая – с переменной y, и правило преобразования есть x -> y x,
      осуществляем подстановку x:= y++x. После этого вызываем функцию упрощения уравнений. */
	((s.x's -> 's.y's 's.x's') e.R1) (t.Tag ((var 'e' s.x) e.LHS)((var 'e' s.y) e.RHS)) e.Other
		= <Eq2 (e.R1) (<Sim (/* EMPTY */)
			(t.Tag (<subst (assign (var 'e' s.x)((var 'e' s.y) (var 'e' s.x)))((var 'e' s.x))(e.LHS)>)
			(<subst (assign (var 'e' s.x)((var 'e' s.y) (var 'e' s.x)))(/*EMPTY*/)(e.RHS)>))
			<subst_2 (assign (var 'e' s.x)((var 'e' s.y)(var 'e' s.x)))e.Other>
		>)>;
	/* 5б. Если левая часть уравнения начинается с переменной x, а правая – с переменной y, и правило преобразования есть y -> x y,
      осуществляем подстановку y:= x++y. После этого вызываем функцию упрощения уравнений. */
	((s.y's -> 's.x's 's.y's') e.R1) (t.Tag ((var 'e' s.x) e.LHS)((var 'e' s.y) e.RHS)) e.Other
		= <Eq2 (e.R1) (<Sim (/* EMPTY */)
			(t.Tag (<subst (assign (var 'e' s.y)((var 'e' s.x)(var 'e' s.y)))(/*EMPTY*/)(e.LHS)>)
			(<subst (assign (var 'e' s.y)((var 'e' s.x) (var 'e' s.y)))((var 'e' s.y))(e.RHS)>))
			<subst_2 (assign (var 'e' s.y)((var 'e' s.x)(var 'e' s.y)))e.Other>
		>)>;
	/* буквенная переменная */
	((s.x1 s.x2 s.x3 s.x4 s.x5't -> 's.Sym'') e.R1) (t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.LHS)(s.Sym e.RHS)) e.Other
		= <Eq2 (e.R1) (<Sim ()
			(t.Tag (<subst (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(s.Sym))(/*Empty*/)(e.LHS)>)
            (<subst (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(s.Sym))(/*Empty*/)(e.RHS)>))
            <subst_2 (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(s.Sym))e.Other>
		>)>;
	/* буквенная переменная */
	((s.x1 s.x2 s.x3 s.x4 s.x5't -> 's.Sym'') e.R1) (t.Tag (s.Sym e.LHS)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.RHS)) e.Other
    	= <Eq2 (e.R1) (<Sim ()
    		(t.Tag (<subst (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(s.Sym))(/*Empty*/)(e.LHS)>)
    		(<subst (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(s.Sym))(/*Empty*/)(e.RHS)>))
    		<subst_2 (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(s.Sym))e.Other>
    	>)>;
    /* буквенная переменная */
   	((s.x1 s.x2 s.x3 s.x4 s.x5't -> 's.x6 s.x7 s.x8 s.x9 s.x10't') e.R1) (e.Processed) (t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.LHS)((var 't' s.x6 s.x7 s.x8 s.x9 s.x10) e.RHS)) e.Other
   		= <Eq2 (e.R1) (<Sim ()
   			(t.Tag (<subst (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)((var 't' s.x6 s.x7 s.x8 s.x9 s.x10)))(/*Empty*/)(e.LHS)>)
            (<subst (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)((var 't' s.x6 s.x7 s.x8 s.x9 s.x10)))(/*Empty*/)(e.RHS)>))
            <subst_2 (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)((var 't' s.x6 s.x7 s.x8 s.x9 s.x10)))e.Other>
   		>)>;
   	/**/
   	((s.x's -> 's.x1 s.x2 s.x3 s.x4 s.x5't ' s.x's') e.R1) (t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.LHS)((var 'e' s.x) e.RHS)) e.Other
   		= <Eq2 (e.R1) (<Sim ()
   			(t.Tag (<subst (assign (var 'e' s.x)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 'e' s.x)))(/*Empty*/)(e.LHS)>)
            (<subst (assign (var 'e' s.x)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 'e' s.x)))((var 'e' s.x))(e.RHS)>))
            <subst_2 (assign (var 'e' s.x)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 'e' s.x)))e.Other>
   		>)>;
   	/**/
   	((s.x's -> 's.x1 s.x2 s.x3 s.x4 s.x5't ' s.x's') e.R1) (t.Tag ((var 'e' s.x) e.LHS)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.RHS)) e.Other
   		= <Eq2 (e.R1) (<Sim ()
   			(t.Tag (<subst (assign (var 'e' s.x) ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 'e' s.x)))((var 'e' s.x))(e.LHS)>)
            (<subst (assign (var 'e' s.x)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 'e' s.x)))(/*Empty*/)(e.RHS)>))
            <subst_2 (assign (var 'e' s.x)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 'e' s.x)))e.Other>
   		>)>;
	/* 7. Во всех прочих случаях считаем, что шаг решения уравнения невозможен. */
	(e.R1) e.Other = False;
}

/* Функция подстановки в выражение имеет входной формат:
   (assign (var s.name) (e.Val))(e.Result)(e.StringToSubstituteIn).
   Реализована хвостовой рекурсией: накапливает строку после подстановки в аргументе e.Result и возвращает ее всю целиком. */
subst {
	/* Нижеследующее правило запрещает обобщение констант, появившихся в уравнении в результате подстановки, посредством применения
      псевдофункции Const__. */
	(assign t.var (e.val))(e.Result) (/*EMPTY*/) = e.Result;
	/* Правило подстановки, не накладывающее запрет на обобщение. */
	(assign (var s.type s.n) (e.val))(e.Result) ((var s.type s.n) e.Rest) = <subst (assign (var s.type s.n) (e.val))(e.Result <Const__ e.val>) (e.Rest)>;
	(assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (e.val))(e.Result) ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.Rest) = <subst (assign (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (e.val))(e.Result <Const__ e.val>) (e.Rest)>;
	(assign t.var (e.val))(e.Result) (t.other e.Rest) = <subst (assign t.var (e.val))(e.Result t.other) (e.Rest)>;
}

/* Функция вызова подстановки ко всем левым и правым частям уравнений в системе.
 Входной формат:   (assign (var s.name) (e.Val)) e.Equations,
где e.Equations либо пусто, либо начинается с уравнения вида ((e.LHS)(e.RHS)). */
subst_2 {
	t.Asg (t.Tag (e.LHS)(e.RHS)) e.Other
		= (t.Tag (<subst t.Asg (/* EMPTY */) (e.LHS)>)(<subst t.Asg (/* EMPTY */) (e.RHS)>))
		<subst_2 t.Asg e.Other>;
	t.Asg /* EMPTY */ = /* EMPTY */;
}	

/* Модифицированная функция упрощения удаляет одинаковые термы с левой и правой стороны уравнения. Имеет входной формат ((e.LHS)(e.RHS))^*. */
Sim {
	/* 1a-left. Удаление одинаковых букв слева и справа. */
	(e.Processed)(t.Tag (s.x e.LHS)(s.x e.RHS)) e.Other = <Sim (e.Processed)(t.Tag (e.LHS)(e.RHS)) e.Other>;
	 /* 1a-right. Удаление одинаковых букв слева и справа. */
	(e.Processed)(t.Tag (e.LHS s.x)(e.RHS s.x)) e.Other = <Sim (e.Processed)(t.Tag (e.LHS)(e.RHS)) e.Other>;
	 /* 1б-left. Удаление одинаковых переменных. */
	(e.Processed)(t.Tag ((var s.type s.n) e.LHS)((var s.type s.n) e.RHS)) e.Other = <Sim (e.Processed)(t.Tag (e.LHS)(e.RHS)) e.Other>;
	/* 1б-right. Удаление одинаковых переменных. */
	(e.Processed)(t.Tag (e.LHS (var s.type s.n))(e.RHS (var s.type s.n))) e.Other = <Sim (e.Processed) (t.Tag (e.LHS)(e.RHS)) e.Other>;
	/* 2а. Уравнение преобразовано к тривиальному тождеству: возвращаем это тождество и упрощаем остальные уравнения в системе. */
	(e.Processed)(t.Tag (/* EMPTY */)(/* EMPTY */)) e.Other = <Sim (e.Processed (t.Tag (/* EMPTY */)(/* EMPTY */))) e.Other>;
	/* 2б-left. Уравнение преобразовано к тривиальному противоречию (поскольку предложение 2б находится ниже, чем 1а-left,
      то s.x не совпадает с s.y): возвращаем противоречивое уравнение и удаляем все остальные уравнения из системы. */
	(e.Processed)(t.Tag (s.x e.LHS)(s.y e.RHS)) e.Other = (t.Tag (s.x)(s.y));
	/* 2б-right. Уравнение преобразовано к тривиальному противоречию (поскольку предложение 2б находится ниже, чем 1а-left,
      то s.x не совпадает с s.y): возвращаем противоречивое уравнение и удаляем все остальные уравнения из системы. */
	(e.Processed)(t.Tag (e.LHS s.x)(e.RHS s.y)) e.Other = (t.Tag (s.x)(s.y));
	/**/
	(e.Processed)(t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.LHS)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.RHS)) e.Other = <Sim (e.Processed)(t.Tag(e.LHS)(e.RHS)) e.Other>;
	/**/
	(e.Processed)(t.Tag(e.LHS (var 't' s.x1 s.x2 s.x3 s.x4 s.x5))(e.RHS (var 't' s.x1 s.x2 s.x3 s.x4 s.x5))) e.Other = <Sim (e.Processed)(t.Tag (e.LHS)(e.RHS)) e.Other>;
	/* 3. Уравнение не преобразовано к тривиальному противоречию, и сокращать больше нечего:
      пытаемся расщепить это уравнение и упрощаем остальные уравнения системы. */
	(e.Processed)(t.Tag (e.x)(e.y)) e.Other =
		<Sim (e.Processed <Split
			(/* EMPTY */)  /* уравнения – результаты расщепления */
			'N' /* текущее состояние разбиения – неопределенное */
			((Const ))((Const )) /* мультимножества букв и переменных частей уравнения пусты */
			((/* EMPTY */)(/* EMPTY */)) /* отщепляемые префиксы тоже пусты */
			(t.Tag (e.x)(e.y))  /* суффиксы совпадают со сторонами уравнения */
		>) e.Other>;
	/* 4. Упрощать больше нечего – заканчиваем работу. */
	(e.Processed)/* EMPTY */ = <SortContr (/* EMPTY */) e.Processed>;
}

SortContr {
	(e.Processed)((s.x)(s.y)) e.Other = ((s.x)(s.y));
	(e.Processed)(e.NormalEq) e.Other = <SortContr (e.Processed (e.NormalEq)) e.Other>;
	(e.Processed) /* EMPTY */ = e.Processed;
}

/* Модифицированная функция упрощения удаляет одинаковые термы с левой и правой стороны уравнения. Имеет входной формат ((e.LHS)(e.RHS))^*. */
Sim2 {
	 /* 1a-left. Удаление одинаковых букв слева и справа. */
	(t.Tag (s.x e.LHS)(s.x e.RHS)) e.Other = <Sim2 (t.Tag (e.LHS)(e.RHS)) e.Other>;
	/* 1a-right. Удаление одинаковых букв слева и справа. */
	(t.Tag (e.LHS s.x)(e.RHS s.x)) e.Other = <Sim2 (t.Tag (e.LHS)(e.RHS)) e.Other>;
	/* 1б-left. Удаление одинаковых переменных. */
	(t.Tag ((var s.type s.n) e.LHS)((var s.type s.n) e.RHS)) e.Other = <Sim2 (t.Tag (e.LHS)(e.RHS)) e.Other>;
	/* 1б-right. Удаление одинаковых переменных. */
	(t.Tag (e.LHS (var s.type s.n))(e.RHS (var s.type s.n))) e.Other = <Sim2 (t.Tag (e.LHS)(e.RHS)) e.Other>;
	/**/
	(t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.LHS)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.RHS)) e.Other = <Sim2 (t.Tag (e.LHS)(e.RHS)) e.Other>;
	/**/
	(t.Tag (e.LHS (var 't' s.x1 s.x2 s.x3 s.x4 s.x5))(e.RHS (var 't' s.x1 s.x2 s.x3 s.x4 s.x5))) e.Other = <Sim2 (t.Tag (e.LHS)(e.RHS)) e.Other>;
	/* 2а. Уравнение преобразовано к тривиальному тождеству: возвращаем это тождество и упрощаем остальные уравнения в системе. */
	(t.Tag (/* EMPTY */)(/* EMPTY */)) e.Other = (t.Tag (/* EMPTY */)(/* EMPTY */)) <Sim2 e.Other>;
	/* 2б-left. Уравнение преобразовано к тривиальному противоречию (поскольку предложение 2б находится ниже, чем 1а-left,
      то s.x не совпадает с s.y): возвращаем противоречивое уравнение и удаляем все остальные уравнения из системы. */
	(t.Tag (s.x e.LHS)(s.y e.RHS)) e.Other = (t.Tag (s.x)(s.y));
	/* 2б-right. Уравнение преобразовано к тривиальному противоречию (поскольку предложение 2б находится ниже, чем 1а-left,
      то s.x не совпадает с s.y): возвращаем противоречивое уравнение и удаляем все остальные уравнения из системы. */
	(t.Tag (e.LHS s.x)(e.RHS s.y)) e.Other = (t.Tag (s.x)(s.y));
	/* 3. Уравнение не преобразовано к тривиальному противоречию, и сокращать больше нечего:
      пытаемся расщепить это уравнение и упрощаем остальные уравнения системы. */
	(t.Tag (e.x)(e.y)) e.Other = (t.Tag (e.x)(e.y))<Sim2 e.Other>;
	/* 4. Упрощать больше нечего – заканчиваем работу. */
	/* EMPTY */ = /* EMPTY */;
}

/* Функция расщепления уравнения в словах по равносоставленности частей.
                        Расщепление делается только слева!
                       Входной формат функции:
                       (e.Result) s.Log (e.LmultiSet)(e.RmultiSet)((e.Lpref)(e.Rpref))((e.LHSRest)(e.RHSRest)),
                        где:
                               e.Result – список уравнений, уже отделенных от исходного;
                               s.Log :: = 'N' | 'T' | 'F'   – статус текущего расщепления, где
                                                               'N' – статус не определен, 'T' – расщепление корректно, 'F' – некорректно;
                              (e.Lmultiset) и (e.Rmultiset) – мультимножества переменных и букв, входящих в слова e.Lpref и e.Rpref соответственно;
                              e.Lpref и e.Rpref – префиксы левой и правой сторон уравнения, которые проверяются на равносоставленность. Всегда (по построению) состоят из одинакового числа термов.
                              e.LHSRest и e.RHSRest – остатки левой и правой сторон уравнения.
                    */
Split {
	/* 1а. Статус расщепления не определен (очередное отделение термов слева и справа уравнения еще не сделано), но осталось еще хотя бы по одному терму слева и справа уравнения.
      Присоединяем соответствующие термы справа к префиксам и включаем их в мультимножества элементов префиксов. После чего проверяем эти мультимножества на совпадение – вызываем
      функцию CountMS. */
	(e.Result)'N'(e.MS1)(e.MS2)((e.LPref)(e.RPref))(t.Tag (t.L1 e.LHS)(t.R1 e.RHS))
		= <Split 
			(e.Result)
			<CountMS <Include t.L1 (/* EMPTY */)(e.MS1)><Include t.R1 (/* EMPTY */)(e.MS2)>>
			((e.LPref t.L1)(e.RPref t.R1))
			(t.Tag (e.LHS)(e.RHS))
		>;
	/* 1б. Статус текущего расщепления: некорректное. Делаем попытку следующего расщепления (см. предложение 1а). */
	(e.Result)'F'(e.MS1)(e.MS2)((e.LPref)(e.RPref))(t.Tag (t.L1 e.LHS)(t.R1 e.RHS))
		= <Split 
			(e.Result)
			<CountMS <Include t.L1 (/* EMPTY */)(e.MS1)><Include t.R1 (/* EMPTY */)(e.MS2)>>
			((e.LPref t.L1)(e.RPref t.R1))
			(t.Tag (e.LHS)(e.RHS))
		>;
	/* 2. Статус текущего расщепления – корректное. Составляем из префиксов новое уравнение и переходим к анализу оставшейся части исходного уравнения, обнулив расщепление. */
	(e.Result)'T'(e.MS1)(e.MS2)((e.LPref)(e.RPref))(t.Tag (e.LHS)(e.RHS))
		= <Split
			(e.Result (t.Tag (e.LPref)(e.RPref)))
			'N'
			((Const ))((Const ))
			((/* EMPTY */)(/* EMPTY */))
			<Sim2 (t.Tag (e.LHS)(e.RHS))>
		>;
	/* 3. Расщеплять было нечего – уравнение пустое. Возвращаем все остальные уравнения. */
	(e.Result)s.Log(e.MS1)(e.MS2)((/* EMPTY */)(/* EMPTY */))(t.Tag (/* EMPTY */)(/* EMPTY */))
		= e.Result;
	/* 4. Или в левой, или в правой части уравнения больше не осталось термов: пытаемся расщепить остаток уравнения справа. */
	(e.Result)s.Log(e.MS1)(e.MS2)((e.LPref)(e.RPref))(t.Tag (e.LHS)(e.RHS))
		= <SplitRight 
			(e.Result)
			'N'((Const ))((Const ))
			((/* EMPTY */)(/* EMPTY */))
			<Sim2 (t.Tag (e.LPref e.LHS)(e.RPref e.RHS))>>;
}

/* Функция добавления элемента с кратностью 1 в мультимножество.
    Входной формат:
    t.Term (e.SkippedElements)(e.RestOfMultiset),
    где e.SkippedElements и e.RestOfMultiset – это последовательности элементов вида ((var s.name) e.Number) или (Const e.Number),
    причем (Const e.Number) всегда присутствует в e.SkippedElements ++ e.RestOfMultiset – на последнем месте.
*/
Include {
	/* 1. Добавляется буква: увеличиваем счетчик констант, стоящий в мультимножестве всегда последним. */
	s.Sym (e.Prev)(e.MS (Const e.Counter)) = (e.Prev e.MS (Const e.Counter'I'));
	/* 2. Добавляется очередное вхождение уже присутствующей в мультимножестве e-переменной: увеличиваем соответствующий счетчик. */
	(var 'e' s.name)(e.Prev)(((var 'e' s.name) e.Counter) e.Rest)
		= (e.Prev ((var 'e' s.name) e.Counter'I') e.Rest);
	/* 3. Очередной элемент мультимножества не является счетчиком вхождений данной e-переменной: делаем шаг по мультимножеству. */
	(var 'e' s.name)(e.Prev)(t.Other e.MS) = <Include (var 'e' s.name)(e.Prev t.Other)(e.MS)>;
	 /* 4. Во всем мультимножестве не нашлось элементов, считающих вхождения данной e-переменной: заводим для нее новый счетчик со значением 1
      и помещаем его в начало мультимножества. */
	(var 'e' s.name)(e.Prev)(/* EMPTY */) = (((var 'e' s.name) 'I') e.Prev);
	/**/
	(var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(e.Prev)(e.MS (Const e.Counter))
    	= (e.Prev e.MS (Const e.Counter'I'));
}

/* Вспомогательная функция проверки равенства двух мультимножеств.
                                             Входной формат: (e.Multiset1)(e.Multiset2),
                                            где e.Multiset1 и e.Multiset2 – последовательности элементов вида ((var s.name) e.Number), за которыми следует единственный элемент вида (Const e.Number).
                                         */
CountMS {
	(t.1 e.M1) (e.M2) = <AreEqual (e.M1)(<ElMinus t.1 (/* EMPTY */)(e.M2)>)> (t.1 e.M1) (e.M2);
}

/* Функция проверки двух мультимножеств на равенство (в т.ч. по кратности каждого элемента).
    Входной формат: (e.Multiset1)(e.Multiset2 e.Marker),
    где e.Multiset1 и e.Multiset2 – пустые слова либо последовательности элементов вида ((var s.name) e.Number),
    за которыми следует единственный элемент вида (Const e.Number); e.Marker – пустое слово или терм FALSE.
*/
AreEqual {
	/* 1. Если второе мультимножество отмечено как заведомо не равное первому – возвращаем 'F'. */
	(e.M1)(e.M2 FALSE) = 'F';
	/* 2. Мультимножества оказались поэлементно равными – возвращаем 'T'. */
	(/* EMPTY */)(/* EMPTY */) = 'T';
	/* 3a. Первое мультимножество оказалось строгим подмножеством второго – возвращаем 'F'. */
	(/* EMPTY */)(e.Other) = 'F';
	/* 3б. Второе мультимножество оказалось строгим подмножеством первого – возвращаем 'F'. */
	(e.Other)(/* EMPTY */) = 'F';
	/* 4. В остальных случаях удаляем первый элемент первого мультимножества из второго как из множества.
    Если оказалось, что этот элемент отсутствует во втором мультимножестве или присутствует с другой кратностью, тогда помечаем второе множество как заведомо неравное первому. */
	(t.1 e.M1)(e.M2) = <AreEqual (e.M1)(<ElMinus t.1 (/* EMPTY */)(e.M2)>)>;
	
}

/* Функция вычитания элемента из мультимножества. Считается выполненной успешно, если данный элемент
   удален из мультимножества полностью, т.е. кратность вычитаемого элемента совпадает с кратностью его в уменьшаемом множестве. */
ElMinus {
	/* 1. Счетчик констант всегда является последним элементом мультимножества, поэтому при вычитании элемента,
      считающего константы, достаточно убедиться в совпадении количества вхождений букв и буквенных переменных. */
	(Const e.Counter) (/* EMPTY */)(e.Rest (Const e.Counter2))
		= e.Rest <CountMinus Const (e.Counter)(e.Counter2)>;
	/* 2. Если в мультимножестве нашелся счетчик нужной переменной – проверяем совпадение кратностей. */
	((var 'e' s.name) e.Counter) (e.Rest)(((var 'e' s.name) e.Counter2) e.Next)
		= e.Rest e.Next <CountMinus (var 'e' s.name)(e.Counter)(e.Counter2)>;
	((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.Counter) (e.Rest)(((var 't' s.x1 s.x2 s.x3 s.x4 s.x5) e.Counter2) e.Next)
		= e.Rest e.Next <CountMinus (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(e.Counter)(e.Counter2)>;
	/* 3. Пробегаем очередной элемент мультимножества, не являющийся искомым счетчиком. */
	t.El (e.Rest)(t.Other e.Next)
		= <ElMinus t.El (e.Rest t.Other)(e.Next)>;
	/* 4. Искомого счетчика не нашлось – возвращаем все просмотренное мультимножество и флаг FALSE с
    указанием на то, что в мультимножестве не оказалось элемента с нужной кратностью. */
	t.El (e.Rest)(/* EMPTY */) = e.Rest GREATER FALSE;
}

/* Функция проверки на равенство двух унарных чисел. В случае успеха возвращает пустое слово.
В случае неудачи – константу FALSE с указанием знака сравнения чисел. */
CountMinus {
	t.Name (/* EMPTY */)(/* EMPTY */) = /* EMPTY */;
	t.Name (s.C e.Other)(s.C e.Other2) = <CountMinus t.Name (e.Other)(e.Other2)>;
	t.Name (/* EMPTY */)(e.Number) = LESSER FALSE;
	t.Name (e.Number)(/* EMPTY */) = GREATER FALSE;
}

/*********************************************************************************************************************/
/*                             Добавочные функции интерпретатора Int-Split-Sym                                       */
/*********************************************************************************************************************/

SplitRight {
	/* 1а. Статус расщепления не определен, но осталось еще хотя бы по одному терму слева и справа в уравнении.
      Присоединяем соответствующие термы слева к префиксам и включаем их в мультимножества элементов префиксов.
      После чего проверяем эти мультимножества на совпадение. Вызываем функцию CountMS. */
  (e.Result)'N'(e.MS1)(e.MS2)((e.LSuff)(e.RSuff))(t.Tag (e.LHS t.LL)(e.RHS t.RL))
	= <SplitRight 
		(e.Result)
		<CountMS 
			<Include t.LL (/* EMPTY */)(e.MS1)>
			<Include t.RL (/* EMPTY */)(e.MS2)>
		>
		((t.LL e.LSuff)(t.RL e.RSuff))
		(t.Tag (e.LHS)(e.RHS))
	>;
	/* 1б. Статус текущего расщепления: некорректное. Делаем попытку следующего расщепления (см. предложение 1а). */
  (e.Result)'F'(e.MS1)(e.MS2)((e.LSuff)(e.RSuff))(t.Tag (e.LHS t.LL)(e.RHS t.RL))
	= <SplitRight 
		(e.Result)
		<CountMS 
			<Include t.LL (/* EMPTY */)(e.MS1)>
			<Include t.RL (/* EMPTY */)(e.MS2)>
		>
		((t.LL e.LSuff)(t.RL e.RSuff))
		(t.Tag (e.LHS)(e.RHS))
	>;
	/* 2. Статус текущего расщепления: корректное. Составляем из суффиксов новое уравнение и переходим к анализу оставшейся части исходного уравнения,
    обнулив расщепление. */
  (e.Result)'T'(e.MS1)(e.MS2)((e.LSuff)(e.RSuff))(t.Tag (e.LHS)(e.RHS))
	= <SplitRight
		(e.Result (t.Tag (e.LSuff)(e.RSuff)))
		'N'
		((Const ))((Const ))
		((/* EMPTY */)(/* EMPTY */))
		<Sim2 (t.Tag (e.LHS)(e.RHS))>
	>;
	/* 3. Расщеплять было нечего – уравнение пустое. Возвращаем все остальные уравнения системы. */
  (e.Result)s.Log(e.MS1)(e.MS2)((/* EMPTY */)(/* EMPTY */))(t.Tag (/* EMPTY */)(/* EMPTY */))
		= e.Result;
	/* 4. Или в левой, или в правой части уравнения больше не осталось термов – помещаем остаток уравнения в итоговую систему уравнений самым первым
    и проверяем, не является ли он противоречивым по кратности переменных. */
  (e.Result)s.Log(e.MS1)(e.MS2)((e.LSuff)(e.RSuff))(t.Tag (e.LHS)(e.RHS))
	= <SubjugateEq 
		<YieldCheckSubMS 
			(<AddElsToMS (e.LHS)(e.MS1)>)
			(<AddElsToMS (e.RHS)(e.MS2)>)
		>
		<Sim2 (t.Tag (e.LHS e.LSuff)(e.RHS e.RSuff))>
	> 
	e.Result;
}

/* Функция вывода результата анализа уравнения на противоречивость по кратности. Если уравнение оказывается противоречиво (правило 2),
  тогда оно заменяется на тривиально противоречивое уравнение. */
SubjugateEq {
	False (t.Tag (e.Eq1)(e.Eq2)) = (t.Tag (e.Eq1)(e.Eq2));
	True (t.Tag (e.Eq1)(e.Eq2)) = (t.Tag ('A')('B'));
}

/* Решение задачи:
    существует ли разность мультимножеств e.MS1 и e.MS2. Разность ищется как разность именно мультимножеств,
     т. е. с учетом     кратности элементов.
     Входной формат: s.Flag (e.MultiSet1)(e.MultiSet2). */
SubtractMS {
	/* 1. Если первое мультимножество включало элементы второго, и второе исчерпано, тогда разность существует. */
	GREATER (e.MS1)(/* EMPTY */) = True;
	/* 2. Если второе мультимножество включало элементы первого, и первое исчерпано, тогда разность существует. */
	LESSER (/* EMPTY */)(e.MS2) = True;
	/* 3а, б. Если флаг сравнения мультимножеств однозначный, и ни одно из них не исчерпано, запускаем итерацию проверки вхождения во второе
      множество очередного элемента первого. */
	GREATER (t.El e.MS1)(e.MS2) = <CheckInfo GREATER (<ElMinus t.El (/* EMPTY */)(e.MS2)>)(e.MS1)>;
	LESSER (t.El e.MS1)(e.MS2) = <CheckInfo LESSER (<ElMinus t.El (/* EMPTY */)(e.MS2)>)(e.MS1)>;
	/* 4. Если флаг сравнения мультимножеств иной (несравнимы), возвращаем False. */
	t.Other (e.MS1)(e.MS2) = False;
}

/* Функция анализа результата проверки элемента мультимножества на включение – в контексте предыдущего сравнения мультимножеств. */
CheckInfo {
	/* 1. Если нехватка/избыток вхождений элемента в мультимножество согласуется с предыдущим анализом, тогда  продолжаем поиск разности
      мультимножеств. */
	s.Log (e.MS2 s.Log FALSE)(e.MS1) = <SubtractMS s.Log (e.MS1)(e.MS2)>;
	/* 2а,б. Если результат анализа данного элемента мультимножества противоположен результату предыдущего анализа, тогда
      возвращаем флаг несравнимости мультимножеств. */
	GREATER (e.MS2 LESSER FALSE)(e.MS1) = <SubtractMS NONCOMP (e.MS1)(e.MS2)>;
	LESSER (e.MS2 GREATER FALSE)(e.MS1) = <SubtractMS NONCOMP (e.MS1)(e.MS2)>;
	 /* 3. Если данный элемент первого мультимножества в точности (с учетом кратности) повторяет элемент второго мультимножества,
      тогда продолжаем анализ независимо от предыдущих результатов. */
	s.Marker (e.MS2)(e.MS1) = <SubtractMS s.Marker (e.MS1)(e.MS2)>;
}

/* Анализ результата сравнения счетчиков букв в мультимножествах. Этот шаг является выделенным, поскольку от него зависит, удастся ли
  получить информацию о противоречивости уравнения. */
YieldCheckSubMS2 {
	 /* 1. Если счетчики букв в двух мультимножествах совпадают, дальнейший анализ не может показать противоречивость уравнения. */
	/* EMPTY */ (e.MS1)(e.MS2) = False;
	/* 2. В противном случае проверяем, сопровождается ли избыток букв в одной из частей уравнения избытком вхождений переменных. */
	s.Cmp FALSE (e.MS1)(e.MS2) = <SubtractMS s.Cmp (e.MS1)(e.MS2)>;
}

/* Вспомогательная функция, выделяющая первый шаг анализа мультимножеств термов частей уравнения:
  анализ количества констант в мультимножествах. */
YieldCheckSubMS {
	(e.MS1 t.Const1)(e.MS2 t.Const2)
		= <YieldCheckSubMS2 <ElMinus t.Const1 (/* EMPTY */)(t.Const2)>(e.MS1)(e.MS2)>;
}

/* Функция, добавляющая последовательность элементов (как термов кратности 1) в мультимножество. */
AddElsToMS {
	(t.El e.Other)(e.MS) = <AddElsToMS (e.Other) <Include t.El(/* EMPTY */)(e.MS)>>;
	(/* EMPTY */)(e.MS) = e.MS;
}

/*********************************************************************************************************************/
/*                                              Буквенные переменные                                                 */
/*********************************************************************************************************************/
/* буквенной переменной будем считать последовательность из ровно 5 заглавных букв, заканчивающася на t */

/* Вспомогательная функция поиска максимальной t переменной */
FindMaxNameT {
	(e.Max)(t.Tag ((var 't' e.Name) e.LHS)(e.RHS)) e.Other = <FindMaxNameT (<SelectMax (e.Name) (e.Max)>) (t.Tag (e.LHS)(e.RHS)) e.Other>;
	(e.Max)(t.Tag (e.LHS)((var 't' e.Name) e.RHS)) e.Other = <FindMaxNameT (<SelectMax (e.Name) (e.Max)>) (t.Tag (e.LHS)(e.RHS)) e.Other>;
	(e.Max)(t.Tag (t.Any e.LHS)(t.Any2 e.RHS)) e.Other = <FindMaxNameT (e.Max) (t.Tag (e.LHS)(e.RHS)) e.Other>;
	(e.Max)(t.Tag (t.Any e.LHS)()) e.Other = <FindMaxNameT (e.Max) (t.Tag (e.LHS)()) e.Other>;
	(e.Max)(t.Tag ()(t.Any e.RHS)) e.Other = <FindMaxNameT (e.Max) (t.Tag ()(e.RHS)) e.Other>;
	(e.Max)(t.Tag (/*EMPTY*/)(/*EMPTY*/)) e.Other = <FindMaxNameT (e.Max) e.Other>;
	(e.Max) /* EMPTY */ = e.Max;
}

SelectMax {
	(e.Current) (e.Max) = <SelectMax (e.Current) <CompareNamesT (e.Current) (e.Max)> (e.Max)>;
	(e.Current) 'G' (e.Max) = e.Current;
	(e.Current) s.Log (e.Max) = e.Max;
}

/*Функция сравнения 2 имен буквенных переменных*/
CompareNamesT {
	(s.Sym e.x) (s.Sym e.y) 'E' = <CompareNamesT (e.x) (e.y) 'E'>;
	(s.Sym e.x) (s.Sym2 e.y) 'E' = <CompareNamesT (e.x) (e.y) <CompareLetters s.Sym s.Sym2>>;
	(s.Sym e.x) (s.Sym2 e.y) s.Log = s.Log;
	(/* EMPTY */) (/* EMPTY */) s.Log = s.Log;
	(s.Sym e.x) (s.Sym e.y) = <CompareNamesT (e.x) (e.y) 'E'>;
	(s.Sym e.x) (s.Sym2 e.y) = <CompareNamesT (e.x) (e.y) <CompareLetters s.Sym s.Sym2>>;
	(/* EMPTY */) (e.x) = 'L';
	(e.x) (/* EMPTY */) = 'G';
	() () = 'E';
}

/*генерация следующего имени переменной (генерация размещений с повторениями) */
NextNameT {
	(e.x'Z') e.Counter = <NextNameT (e.x) e.Counter'I'>;
	(e.x s.Sym) e.Counter = e.x <IncSym s.Sym> <BuildNameA e.Counter>;
	/* EMPTY */ = 'AAAAA';
	e.Name = <NextNameT (e.Name) ''>;
}

/*сбор строки A нужной длины для дописывания в конец*/
BuildNameA {
	(e.Result) /* EMPTY */ = e.Result;
	(e.Result) e.X'I' = <BuildNameA (e.Result 'A') e.X>;
	e.X = <BuildNameA () e.X>
}

/*функция сравнения символов*/
CompareLetters {
	s.Sym s.Sym = 'E';
	'B' 'A' = 'G';
	'C' 'A' = 'G'; 'C' 'B' = 'G';
	'D' 'A' = 'G'; 'D' 'B' = 'G'; 'D' 'C' = 'G';
	'E' 'A' = 'G'; 'E' 'B' = 'G'; 'E' 'C' = 'G'; 'E' 'D' = 'G';
	'F' 'A' = 'G'; 'F' 'B' = 'G'; 'F' 'C' = 'G'; 'F' 'D' = 'G'; 'F' 'E' = 'G';
	'G' 'A' = 'G'; 'G' 'B' = 'G'; 'G' 'C' = 'G'; 'G' 'D' = 'G'; 'G' 'E' = 'G'; 'G' 'F' = 'G';
	'H' 'A' = 'G'; 'H' 'B' = 'G'; 'H' 'C' = 'G'; 'H' 'D' = 'G'; 'H' 'E' = 'G'; 'H' 'F' = 'G'; 'H' 'G' = 'G';
	'I' 'A' = 'G'; 'I' 'B' = 'G'; 'I' 'C' = 'G'; 'I' 'D' = 'G'; 'I' 'E' = 'G'; 'I' 'F' = 'G'; 'I' 'G' = 'G'; 'I' 'H' = 'G';
	'J' 'A' = 'G'; 'J' 'B' = 'G'; 'J' 'C' = 'G'; 'J' 'D' = 'G'; 'J' 'E' = 'G'; 'J' 'F' = 'G'; 'J' 'G' = 'G'; 'J' 'H' = 'G'; 'J' 'I' = 'G';
	'K' 'A' = 'G'; 'K' 'B' = 'G'; 'K' 'C' = 'G'; 'K' 'D' = 'G'; 'K' 'E' = 'G'; 'K' 'F' = 'G'; 'K' 'G' = 'G'; 'K' 'H' = 'G'; 'K' 'I' = 'G'; 'K' 'J' = 'G';
	'L' 'A' = 'G'; 'L' 'B' = 'G'; 'L' 'C' = 'G'; 'L' 'D' = 'G'; 'L' 'E' = 'G'; 'L' 'F' = 'G'; 'L' 'G' = 'G'; 'L' 'H' = 'G'; 'L' 'I' = 'G'; 'L' 'J' = 'G'; 'L' 'K' = 'G';
	'M' 'A' = 'G'; 'M' 'B' = 'G'; 'M' 'C' = 'G'; 'M' 'D' = 'G'; 'M' 'E' = 'G'; 'M' 'F' = 'G'; 'M' 'G' = 'G'; 'M' 'H' = 'G'; 'M' 'I' = 'G'; 'M' 'J' = 'G'; 'M' 'K' = 'G'; 'M' 'L' = 'G';
	'N' 'A' = 'G'; 'N' 'B' = 'G'; 'N' 'C' = 'G'; 'N' 'D' = 'G'; 'N' 'E' = 'G'; 'N' 'F' = 'G'; 'N' 'G' = 'G'; 'N' 'H' = 'G'; 'N' 'I' = 'G'; 'N' 'J' = 'G'; 'N' 'K' = 'G'; 'N' 'L' = 'G'; 'N' 'M' = 'G';
	'O' 'A' = 'G'; 'O' 'B' = 'G'; 'O' 'C' = 'G'; 'O' 'D' = 'G'; 'O' 'E' = 'G'; 'O' 'F' = 'G'; 'O' 'G' = 'G'; 'O' 'H' = 'G'; 'O' 'I' = 'G'; 'O' 'J' = 'G'; 'O' 'K' = 'G'; 'O' 'L' = 'G'; 'O' 'M' = 'G'; 'O' 'N' = 'G';
	'P' 'A' = 'G'; 'P' 'B' = 'G'; 'P' 'C' = 'G'; 'P' 'D' = 'G'; 'P' 'E' = 'G'; 'P' 'F' = 'G'; 'P' 'G' = 'G'; 'P' 'H' = 'G'; 'P' 'I' = 'G'; 'P' 'J' = 'G'; 'P' 'K' = 'G'; 'P' 'L' = 'G'; 'P' 'M' = 'G'; 'P' 'N' = 'G'; 'P' 'O' = 'G';
	'Q' 'A' = 'G'; 'Q' 'B' = 'G'; 'Q' 'C' = 'G'; 'Q' 'D' = 'G'; 'Q' 'E' = 'G'; 'Q' 'F' = 'G'; 'Q' 'G' = 'G'; 'Q' 'H' = 'G'; 'Q' 'I' = 'G'; 'Q' 'J' = 'G'; 'Q' 'K' = 'G'; 'Q' 'L' = 'G'; 'Q' 'M' = 'G'; 'Q' 'N' = 'G'; 'Q' 'O' = 'G'; 'Q' 'P' = 'G';
	'R' 'A' = 'G'; 'R' 'B' = 'G'; 'R' 'C' = 'G'; 'R' 'D' = 'G'; 'R' 'E' = 'G'; 'R' 'F' = 'G'; 'R' 'G' = 'G'; 'R' 'H' = 'G'; 'R' 'I' = 'G'; 'R' 'J' = 'G'; 'R' 'K' = 'G'; 'R' 'L' = 'G'; 'R' 'M' = 'G'; 'R' 'N' = 'G'; 'R' 'O' = 'G'; 'R' 'P' = 'G'; 'R' 'Q' = 'G';
	'S' 'A' = 'G'; 'S' 'B' = 'G'; 'S' 'C' = 'G'; 'S' 'D' = 'G'; 'S' 'E' = 'G'; 'S' 'F' = 'G'; 'S' 'G' = 'G'; 'S' 'H' = 'G'; 'S' 'I' = 'G'; 'S' 'J' = 'G'; 'S' 'K' = 'G'; 'S' 'L' = 'G'; 'S' 'M' = 'G'; 'S' 'N' = 'G'; 'S' 'O' = 'G'; 'S' 'P' = 'G'; 'S' 'Q' = 'G'; 'S' 'R' = 'G';
	'T' 'A' = 'G'; 'T' 'B' = 'G'; 'T' 'C' = 'G'; 'T' 'D' = 'G'; 'T' 'E' = 'G'; 'T' 'F' = 'G'; 'T' 'G' = 'G'; 'T' 'H' = 'G'; 'T' 'I' = 'G'; 'T' 'J' = 'G'; 'T' 'K' = 'G'; 'T' 'L' = 'G'; 'T' 'M' = 'G'; 'T' 'N' = 'G'; 'T' 'O' = 'G'; 'T' 'P' = 'G'; 'T' 'Q' = 'G'; 'T' 'R' = 'G'; 'T' 'S' = 'G';
	'U' 'A' = 'G'; 'U' 'B' = 'G'; 'U' 'C' = 'G'; 'U' 'D' = 'G'; 'U' 'E' = 'G'; 'U' 'F' = 'G'; 'U' 'G' = 'G'; 'U' 'H' = 'G'; 'U' 'I' = 'G'; 'U' 'J' = 'G'; 'U' 'K' = 'G'; 'U' 'L' = 'G'; 'U' 'M' = 'G'; 'U' 'N' = 'G'; 'U' 'O' = 'G'; 'U' 'P' = 'G'; 'U' 'Q' = 'G'; 'U' 'R' = 'G'; 'U' 'S' = 'G'; 'U' 'T' = 'G';
	'V' 'A' = 'G'; 'V' 'B' = 'G'; 'V' 'C' = 'G'; 'V' 'D' = 'G'; 'V' 'E' = 'G'; 'V' 'F' = 'G'; 'V' 'G' = 'G'; 'V' 'H' = 'G'; 'V' 'I' = 'G'; 'V' 'J' = 'G'; 'V' 'K' = 'G'; 'V' 'L' = 'G'; 'V' 'M' = 'G'; 'V' 'N' = 'G'; 'V' 'O' = 'G'; 'V' 'P' = 'G'; 'V' 'Q' = 'G'; 'V' 'R' = 'G'; 'V' 'S' = 'G'; 'V' 'T' = 'G'; 'V' 'U' = 'G';
	'W' 'A' = 'G'; 'W' 'B' = 'G'; 'W' 'C' = 'G'; 'W' 'D' = 'G'; 'W' 'E' = 'G'; 'W' 'F' = 'G'; 'W' 'G' = 'G'; 'W' 'H' = 'G'; 'W' 'I' = 'G'; 'W' 'J' = 'G'; 'W' 'K' = 'G'; 'W' 'L' = 'G'; 'W' 'M' = 'G'; 'W' 'N' = 'G'; 'W' 'O' = 'G'; 'W' 'P' = 'G'; 'W' 'Q' = 'G'; 'W' 'R' = 'G'; 'W' 'S' = 'G'; 'W' 'T' = 'G'; 'W' 'U' = 'G'; 'W' 'V' = 'G';
	'X' 'A' = 'G'; 'X' 'B' = 'G'; 'X' 'C' = 'G'; 'X' 'D' = 'G'; 'X' 'E' = 'G'; 'X' 'F' = 'G'; 'X' 'G' = 'G'; 'X' 'H' = 'G'; 'X' 'I' = 'G'; 'X' 'J' = 'G'; 'X' 'K' = 'G'; 'X' 'L' = 'G'; 'X' 'M' = 'G'; 'X' 'N' = 'G'; 'X' 'O' = 'G'; 'X' 'P' = 'G'; 'X' 'Q' = 'G'; 'X' 'R' = 'G'; 'X' 'S' = 'G'; 'X' 'T' = 'G'; 'X' 'U' = 'G'; 'X' 'V' = 'G'; 'X' 'W' = 'G';
	'Y' 'A' = 'G'; 'Y' 'B' = 'G'; 'Y' 'C' = 'G'; 'Y' 'D' = 'G'; 'Y' 'E' = 'G'; 'Y' 'F' = 'G'; 'Y' 'G' = 'G'; 'Y' 'H' = 'G'; 'Y' 'I' = 'G'; 'Y' 'J' = 'G'; 'Y' 'K' = 'G'; 'Y' 'L' = 'G'; 'Y' 'M' = 'G'; 'Y' 'N' = 'G'; 'Y' 'O' = 'G'; 'Y' 'P' = 'G'; 'Y' 'Q' = 'G'; 'Y' 'R' = 'G'; 'Y' 'S' = 'G'; 'Y' 'T' = 'G'; 'Y' 'U' = 'G'; 'Y' 'V' = 'G'; 'Y' 'W' = 'G'; 'Y' 'X' = 'G';
	'Z' 'A' = 'G'; 'Z' 'B' = 'G'; 'Z' 'C' = 'G'; 'Z' 'D' = 'G'; 'Z' 'E' = 'G'; 'Z' 'F' = 'G'; 'Z' 'G' = 'G'; 'Z' 'H' = 'G'; 'Z' 'I' = 'G'; 'Z' 'J' = 'G'; 'Z' 'K' = 'G'; 'Z' 'L' = 'G'; 'Z' 'M' = 'G'; 'Z' 'N' = 'G'; 'Z' 'O' = 'G'; 'Z' 'P' = 'G'; 'Z' 'Q' = 'G'; 'Z' 'R' = 'G'; 'Z' 'S' = 'G'; 'Z' 'T' = 'G'; 'Z' 'U' = 'G'; 'Z' 'V' = 'G'; 'Z' 'W' = 'G'; 'Z' 'X' = 'G'; 'Z' 'Y' = 'G';
	s.Sym s.Sym2 = 'L';
}

/*увелечение одного символа*/
IncSym {
	'A' = 'B';
	'B' = 'C';
	'C' = 'D';
	'D' = 'E';
	'E' = 'F';
	'F' = 'G';
	'G' = 'H';
	'H' = 'I';
	'I' = 'J';
	'J' = 'K';
	'K' = 'L';
	'L' = 'M';
	'M' = 'N';
	'N' = 'O';
	'O' = 'P';
	'P' = 'Q';
	'Q' = 'R';
	'R' = 'S';
	'S' = 'T';
	'T' = 'U';
	'U' = 'V';
	'V' = 'W';
	'W' = 'X';
	'X' = 'Y';
	'Y' = 'Z';
}

/*********************************************************************************************************************/
/*                                              Диофантовы уравнения                                                 */
/*********************************************************************************************************************/

DiophantineSolve {
	(e.System) = <DiophantineSolve Split <SplitGenerated (e.System)>>;
	Split (e.Generated) (e.System) = <DiophantineSolve BuildSet (e.Generated) (e.System) <ToLengthSystemEquation () e.System>>;
	BuildSet (e.Generated) (e.System) (e.Decoded) = <DiophantineSolve FillSystem (e.Generated) (e.System) (e.Decoded) <BuildAllMap (e.Decoded) ()>>;
	FillSystem (e.Generated) (e.System) (e.Decoded) (e.AllSet) t.Size
		= <DiophantineSolve
			RE
			(e.Generated)
			(e.System)
			(e.AllSet)
			(<FillAll () (e.Decoded) (e.AllSet)>)
			<BuildEMatrix t.Size>>;
	RE (e.Generated) (e.System) (e.AllSet) (e.Filled) (e.Matrix) =
		<DiophantineSolve
			K
			(e.Generated)
			(e.System)
			(e.AllSet)
			<MakeRowEchelon <MatrixFromMaps () (e.Filled)> (e.Matrix)>
			<GetRHS (e.Filled) ()>>;
	K (e.Generated) (e.System) (e.AllSet) (e.RowEchelon) (e.Matrix) (e.RHS) =
		<DiophantineSolve
			X
			(e.Generated)
			(e.System)
			(e.AllSet)
			<TransposeMatrix () (e.Matrix)>
			<FindK <TransposeMatrix () (e.RowEchelon)> (e.RHS)>>;
	X (e.Generated) (e.System) (e.AllSet) (e.Matrix) False = False;
	X (e.Generated) (e.System) (e.AllSet) (e.Matrix) (e.K) = <DiophantineSolve Assign (e.Generated) (e.System) (e.AllSet) (e.Matrix) (e.K) <CalcSolution (e.Matrix) (e.AllSet) (e.K)>>;
	Assign (e.Generated) (e.System) (e.AllSet) (e.Matrix) (e.K) False = False;
	Assign (e.Generated) (e.System) (e.AllSet) (e.Matrix) (e.K) (e.Result) = <DiophantineSolve Apply (e.Generated) (e.System) (e.Result)>;
	Apply (e.Generated) (e.System) (e.Solution) = <DiophantineSolve Check (<ApplySolution (e.Generated) (e.System) (e.Solution)>)>;
	Check (e.System) = <DiophantineSolve Checked (e.System) <FindTVarsContradiction (e.System)>>;
	Checked (e.System) False = False;
	Checked (e.System) = e.System;
}

SplitGenerated {
	(e.System) = <SplitGenerated () (e.System)>;
	(e.Result) ((Generated e.Any) e.Other) = <SplitGenerated (e.Result (Generated e.Any)) (e.Other)>;
	(e.Result) (e.Other) = (e.Result) (e.Other);
}

/*отделяем сгенерированные решателем диофантовых уравнения*/
SplitGeneratedProcessed {
	(e.System) = <SplitGeneratedProcessed () (e.System)>;
	(e.Result) ((Processed e.Any) e.Other) = <SplitGeneratedProcessed (e.Result (Processed e.Any)) (e.Other)>;
	(e.Result) ((Generated e.Any) e.Other) = <SplitGeneratedProcessed (e.Result (Processed e.Any)) (e.Other)>;
	(e.Result) (e.Other) = (e.Result) (e.Other);
}

/*сборка мапа с счетчиками переменных*/
BuildMap {
	/*закончили*/
	() (e.Result) = e.Result;
	/*докидываем один элемент*/
	(t.Any e.Rest) (e.Result) = <BuildMap (e.Rest) <AddToMap t.Any () (e.Result)>>;
}

/*добавление элемента в мап (добавление или удаление счетчика)*/
AddToMap {
	/*увеличиваем счетчик константы*/
	s.Sym (e.Prev)(e.MS (Const (t.Counter))) = (e.Prev e.MS (Const (<Add t.Counter 1>)));
	/*увеличиваем счетчик переменной*/
	(var 'e' s.name)(e.Prev)(((var 'e' s.name)  (t.Counter)) e.Rest)
		= (e.Prev ((var 'e' s.name) (<Add t.Counter 1>)) e.Rest);
	/*идет дальше и ищем*/
	(var 'e' s.name)(e.Prev)(t.Other e.MS) = <AddToMap (var 'e' s.name)(e.Prev t.Other)(e.MS)>;
	/*перменная не найдена - добавляем*/
	(var 'e' s.name)(e.Prev)(/* EMPTY */) = (((var 'e' s.name) (1)) e.Prev);
	/*t-переменная. увеличиваем счетчик констант*/
	(var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(e.Prev)(e.MS (Const (t.Counter)))
    	= (e.Prev e.MS (Const (<Add t.Counter 1>)));
}

/*вычитание из множества счетчиков*/
SubElement {
	/*константа*/
	(Const (t.Counter)) (/* EMPTY */)(e.Rest (Const (t.Counter2)))
		= e.Rest (Const (<Sub t.Counter t.Counter2>));
	/*переменная*/
	((var 'e' s.name) (t.Counter)) (e.Rest)(((var 'e' s.name) (t.Counter2)) e.Next)
		= e.Rest ((var 'e' s.name) <SubUnwrap (t.Counter2) (t.Counter)>) e.Next;
	/*продолжение поиска*/
	t.El (e.Rest)(t.Other e.Next)
		= <SubElement t.El (e.Rest t.Other)(e.Next)>;
	/*не найдено, добавить с отрицательным счетчиком */
	((var 'e' s.name) (t.Counter)) (e.Rest)(/* EMPTY */) = ((var 'e' s.name) ('-' t.Counter)) e.Rest;
}

/*разность мапов счетчиков*/
SubMaps {
	/*итерация по 2-му мапу*/
	(e.First) (t.Any e.Second) = <SubMaps (<SubElement  t.Any () (e.First)>) (e.Second)>;
	/*закончили - выходим*/
	(e.First) (/* EMPTY */) = (e.First);
}

/*перевод системы уравнений в систему уравнений на длины*/
ToLengthSystemEquation {
	/*переводим очередное уравнение*/
	(e.Result) (t.Tag (e.LHS)(e.RHS)) e.Rest = <ToLengthSystemEquation (e.Result <SubMaps (<BuildMap (e.LHS) ((Const (0)))>) (<BuildMap (e.RHS) ((Const (0)))>)>) e.Rest>;
	/*закончили - дополняем все уравнения нехватающими переменными и сортируем*/
	(e.Result) = (e.Result);
}

/*добавление нехватающей переменной (конкретный элемент)*/
FillMissingVar {
	((var 'e' s.Name) t.Counter) (e.Processed) (((var 'e' s.Name) t.Counter2) e.Left) = (e.Processed ((var 'e' s.Name) t.Counter2) e.Left);
	((var 'e' s.Name) '-' t.Counter) (e.Processed) (((var 'e' s.Name) t.Counter2) e.Left) = (e.Processed ((var 'e' s.Name) t.Counter2) e.Left);

	((var 'e' s.Name) t.Counter) (e.Processed) (t.Var e.Left) = <FillMissingVar ((var 'e' s.Name) t.Counter) (e.Processed t.Var) (e.Left)>;
	((var 'e' s.Name) t.Counter) (e.Processed) () = (((var 'e' s.Name) (0)) e.Processed);
}

/*добавление из множества*/
FillMissing {
	(e.Eq) (((var 'e' s.Name) t.Counter) e.Left) = <FillMissing <FillMissingVar ((var 'e' s.Name) t.Counter) () (e.Eq)> (e.Left)>;
	(e.Eq) () = (e.Eq);
}

/*добавление нехватающих переменных к каждому уравнению*/
FillAll {
	(e.Result) ((e.Current) e.Left) (e.Set)= <FillAll (e.Result <SortVars <FillMissing (e.Current) (e.Set)>>) (e.Left) (e.Set)>;
	(e.Result) () (e.Set) = e.Result;
}

/*сбор множества всех переменных (одно уравнение)*/
BuildAllMap2 {
	(((var 'e' s.Name) e.Any) e.Current) (e.VarSet) = <BuildAllMap2 (e.Current) <AddToMap (var 'e' s.Name) () (e.VarSet)>>;
	() (e.VarSet) = (e.VarSet);
}

/*сбор множества всех переменных (несколько уравнений)*/
BuildAllMap {
	((e.Current (Const e.Any)) e.Left) (e.VarSet) = <BuildAllMap (e.Left) <BuildAllMap2 (e.Current) (e.VarSet)>>;
	() (e.VarSet) = <SortVars (e.VarSet)> <SetSize (e.VarSet) 0>;
}

/*поиск макимальной переменной*/
FindMinVar {
	() (e.Set (Const e.Any)) = <FindMinVar () (e.Set)>;
	() (((var 'e' s.Name) t.Counter) e.Left) = <FindMinVar ((var 'e' s.Name) t.Counter) (((var 'e' s.Name) t.Counter) e.Left)>;

	((var 'e' s.Name) t.Counter) (((var 'e' s.Name2) t.Counter2) e.Left) = <FindMinVar <SelectMinLetter ((var 'e' s.Name) t.Counter) ((var 'e' s.Name2) t.Counter2)>  (e.Left)>;

	((var 'e' s.Name) t.Counter) () = ((var 'e' s.Name) t.Counter);
	((var 'e' s.Name) '-' t.Counter) () = ((var 'e' s.Name) '-' t.Counter);
}

/*выбор наибольшей переменной*/
SelectMinLetter {
	((var 'e' s.Name) t.Counter) ((var 'e' s.Name2) t.Counter2) = <SelectMinLetter ((var 'e' s.Name) t.Counter) ((var 'e' s.Name2) t.Counter2) <CompareLetters s.Name s.Name2>>;
	((var 'e' s.Name) t.Counter) ((var 'e' s.Name2) t.Counter2) 'L' = ((var 'e' s.Name) t.Counter);
	((var 'e' s.Name) t.Counter) ((var 'e' s.Name2) t.Counter2) s.Log = ((var 'e' s.Name2) t.Counter2);
}

/*удаляем из списка последнюю переменную*/
ExtractMaxVar {
	((var 'e' s.Name) t.Counter) (e.Processed) (((var 'e' s.Name) t.Counter) e.Next) = (e.Processed e.Next);
	((var 'e' s.Name) t.Counter) (e.Processed) (t.Var e.Next) = <ExtractMaxVar ((var 'e' s.Name) t.Counter) (e.Processed t.Var) (e.Next)>;
}

/*сортируем одно уравнение*/
SortVars {
	() = ();
	(e.Vars) = <SortVars () () (e.Vars)>;
	() (e.Processed) ((Const t.Counter)) = (e.Processed (Const t.Counter));
	() (e.Processed) (e.Left) = <SortVars <FindMinVar () (e.Left)> (e.Processed) (e.Left)>;
	((var 'e' s.Name) t.Counter) (e.Processed) (((var 'e' s.Name) t.Counter2)) = (e.Processed ((var 'e' s.Name) t.Counter));
	((var 'e' s.Name) t.Counter) (e.Processed) (e.Left) = <SortVars () (e.Processed ((var 'e' s.Name) t.Counter)) <ExtractMaxVar ((var 'e' s.Name) t.Counter) () (e.Left)>>;
}

/*размер множества*/
SetSize {
	() t.Count = t.Count;
	(t.Any e.AllSet) t.Count = <SetSize (e.AllSet) <Add t.Count 1>>;
}

/*генерация ряда единичной матрицы*/
BuildERow {
	t.Number t.Size = <BuildERow t.Number t.Size 0 t.Size ()>;
	t.Number t.Size t.Current 0 (e.Result) = (e.Result);
	t.Number t.Size t.Number t.Left (e.Result) =
		<BuildERow
			t.Number
			t.Size
			<Add t.Number 1>
			<Sub t.Left 1>
			(e.Result (1))>;
	t.Number t.Size t.Current t.Left (e.Result) =
		<BuildERow
			t.Number
			t.Size
			<Add t.Current 1>
			<Sub t.Left 1>
			(e.Result (0))>;
}

/*генерация единичной матрицы*/
BuildEMatrix {
	t.Size = <BuildEMatrix 0 t.Size t.Size ()>;
	t.Counter 0 t.Size (e.Result) = (e.Result);
	t.Counter t.Left t.Size (e.Result) = <BuildEMatrix <Add t.Counter 1> <Sub t.Left 1> t.Size (e.Result <BuildERow t.Counter t.Size>)>;
}

GetRHS {
	() (e.Result) = (e.Result);
	((e.Any (Const t.Count2)) e.Rest) (e.Result) = <GetRHS (e.Rest) (e.Result t.Count2)>;
}

/*получение транспонированного ряда*/
MakeTransponentRow {
	(e.Truncated) (e.Result) (((Const t.Count2)) e.Rest) = ();
	(e.Truncated) (e.Result) ((((var 'e' s.Name) t.Count) (Const t.Count2)) e.Rest) = <MakeTransponentRow (e.Truncated) (e.Result t.Count) (e.Rest)>;
	(e.Truncated) (e.Result) ((((var 'e' s.Name) t.Count) e.Eq) e.Rest) = <MakeTransponentRow (e.Truncated (e.Eq)) (e.Result t.Count) (e.Rest)>;
	(e.Truncated) (e.Result) () = (e.Truncated) (e.Result);
}

/*получение матрицы из системы уравнений*/
MatrixFromMaps {
	() () = ();
	(e.Result) (e.System) = <MatrixFromMaps () <MakeTransponentRow () () (e.System)>>;
	(e.Result) () (e.Row) = (e.Result (e.Row));
	(e.Result) (e.System) (e.Row) = <MatrixFromMaps (e.Result (e.Row)) <MakeTransponentRow () () (e.System)>>;
}

GetByIndex {
	(e.List) (t.Ind) = <GetByIndex (e.List) t.Ind 0>;
	(e.List) t.Ind = <GetByIndex (e.List) t.Ind 0>;
	(t.Current e.List) t.Ind t.Ind = t.Current;
	(t.Current e.List) t.Ind t.CurrentInd = <GetByIndex (e.List) t.Ind <Add t.CurrentInd 1>>;
}

GetByIndexIfNotZero {
	(e.Row) t.Ind = <GetByIndexIfNotZero <GetByIndex (e.Row) t.Ind >>;
	(0 ) =;
	0 = ;
	t.Result = t.Result;
}

Min {
	(t.Ind1) (t.Ind2) = t.Ind1;
	( t.Ind1) (t.Second t.Ind2) = t.Second t.Ind2;
	(t.First t.Ind1) ( t.Ind2) = t.First t.Ind1;

	((t.First) t.Ind1) ((t.Second) t.Ind2) '+' = (t.Second) t.Ind2;
	(('-' t.First) t.Ind1) ((t.Second) t.Ind2) '+' = (t.Second) t.Ind2;
	((t.First) t.Ind1) (('-' t.Second) t.Ind2) '+' = ('-' t.Second) t.Ind2;
	(('-' t.First) t.Ind1) (('-' t.Second) t.Ind2) '+' = ('-' t.Second) t.Ind2;

	((t.First) t.Ind1) ((t.Second) t.Ind2) s.Log = (t.First) t.Ind1;
	(('-' t.First) t.Ind1) ((t.Second) t.Ind2) s.Log = ('-' t.First) t.Ind1;
	((t.First) t.Ind1) (('-' t.Second) t.Ind2) s.Log = (t.First) t.Ind1;
	(('-' t.First) t.Ind1) (('-' t.Second) t.Ind2) s.Log = ('-' t.First) t.Ind1;

	((t.First) t.Ind1) ((t.Second) t.Ind2) = <Min ((t.First) t.Ind1) ((t.Second) t.Ind2) <IsNegative (<Sub t.First t.Second>)>>;
	(('-' t.First) t.Ind1) ((t.Second) t.Ind2) = <Min (('-' t.First) t.Ind1) ((t.Second) t.Ind2) <IsNegative (<Sub t.First t.Second>)>>;
	((t.First) t.Ind1) (('-' t.Second) t.Ind2) = <Min ((t.First) t.Ind1) (('-' t.Second) t.Ind2) <IsNegative (<Sub t.First t.Second>)>>;
	(('-' t.First) t.Ind1) (('-' t.Second) t.Ind2) = <Min (('-' t.First) t.Ind1) (('-' t.Second) t.Ind2) <IsNegative (<Sub t.First t.Second>)>>;
}

FindMin {
	(e.System) t.CurrentRow t.CurrentColumn = <FindMin (e.System) 0 t.CurrentRow t.CurrentColumn <IsNegative (<Sub 0 t.CurrentRow>)> ()>;
	((e.Row) e.System) t.Skipped t.CurrentRow t.CurrentColumn '-' () = <FindMin (e.System) <Add t.Skipped 1> t.CurrentRow t.CurrentColumn <IsNegative (<Sub <Add t.Skipped 1> t.CurrentRow>)> ()>;
	((e.Row) e.System) t.Skipped t.CurrentRow t.CurrentColumn '0' () = <FindMin (e.System) <Add t.Skipped 1> t.CurrentRow t.CurrentColumn '+' (<GetByIndexIfNotZero (e.Row) t.CurrentColumn> t.Skipped)>;
	((e.Row) e.System) t.Skipped t.CurrentRow t.CurrentColumn s.Log (t.MinIndex) = <FindMin (e.System) <Add t.Skipped 1> t.CurrentRow t.CurrentColumn '+' (<GetByIndexIfNotZero (e.Row) t.CurrentColumn> t.Skipped)>;
	((e.Row) e.System) t.Skipped t.CurrentRow t.CurrentColumn s.Log (t.CurrentMin t.MinIndex) = <FindMin (e.System) <Add t.Skipped 1> t.CurrentRow t.CurrentColumn '+' (<Min (t.CurrentMin t.MinIndex) (<GetByIndexIfNotZero (e.Row) t.CurrentColumn> t.Skipped)>)>;
	() t.Skipped t.CurrentRow t.CurrentColumn s.Log (t.CurrentMin t.MinIndex) = (t.CurrentMin t.MinIndex);
	() t.Skipped t.CurrentRow t.CurrentColumn s.Log (t.MinIndex) = ();
}

CalcMultiplier {
	t.Value t.ToSubValue = <CalcMultiplier <DivUnwrap t.Value t.ToSubValue>>;
	('-' t.Value) = (t.Value);
	(t.Value) = ('-' t.Value);
}

AddUnwrap {
	(t.First) (t.Second) = (<Add t.First t.Second>);
	('-' t.First) (t.Second) = (<Sub t.Second t.First>);
	(t.First) ('-' t.Second) = (<Sub t.First t.Second>);
	('-' t.First) ('-' t.Second) = ('-' <Add t.First t.Second>);
}

SubUnwrap {
	(t.First) (t.Second) = (<Sub t.First t.Second>);
	('-' t.First) (t.Second) = ('-' <Add t.Second t.First>);
	(t.First) ('-' t.Second) = (<Add t.First t.Second>);
	('-' t.First) ('-' t.Second) = (<Sub t.Second t.First>);
}

MulUnwrap {
	(0) t.Any = (0);
	(t.Any) (0) = (0);
	(t.First) (t.Second) = (<Mul t.First t.Second>);
	('-' t.First) (t.Second) = ('-' <Mul t.First t.Second>);
	(t.First) ('-' t.Second) = ('-' <Mul t.First t.Second>);
	('-' t.First) ('-' t.Second) = (<Mul t.First t.Second>);
}

ModUnwrap {
	(0) (t.Any) = (0);
	(t.First) (t.Second) = (<Mod t.First t.Second>);
	('-' t.First) (t.Second) = (<Mod t.First t.Second>);
	(t.First) ('-' t.Second) = (<Mod t.First t.Second>);
	('-' t.First) ('-' t.Second) = (<Mod t.First t.Second>);
}

DivUnwrap {
	(0) t.Any = (0);
	(t.Value) (t.ToSubValue) = (<Div t.Value t.ToSubValue>);
	('-' t.Value) (t.ToSubValue) = ('-' <Div t.Value t.ToSubValue>);
	(t.Value) ('-' t.ToSubValue) = ('-' <Div t.Value t.ToSubValue>);
	('-' t.Value) ('-' t.ToSubValue) = (<Div t.Value t.ToSubValue>);
}

ReplaceElement {
	(e.List) t.Value (t.Index) = <ReplaceElement () (e.List) t.Value t.Index 0>;
	(e.List) t.Value t.Index = <ReplaceElement () (e.List) t.Value t.Index 0>;
	(e.Processed) (t.Any e.List) t.Value t.Index t.Index = (e.Processed t.Value e.List);
	(e.Processed) (t.Any e.List) t.Value t.Index t.Current = <ReplaceElement (e.Processed t.Any) (e.List) t.Value t.Index <Add t.Current 1>>;
}

SubRow {
	(e.Row) (e.RowToSub) t.Multiplier = <SubRow Started () (e.Row) (e.RowToSub) t.Multiplier>;
	Started (e.Result) (t.Element e.Row) (t.ToSubElement e.RowToSub) t.Multiplier = <SubRow Started (e.Result <AddUnwrap t.Element <MulUnwrap t.Multiplier t.ToSubElement>>) (e.Row) (e.RowToSub) t.Multiplier>;
	Started (e.Result) () () t.Multiplier = (e.Result);
}

SubRowWrapper {
	(e.ProcessedSystem) (e.ProcessedMatrix) (e.Row) (e.Row2) (e.RowToSub) (e.RowToSub2) t.Value t.CurrentRow t.CurrentColumn t.Ind
		= <SubRowWrapper (e.ProcessedSystem) (e.ProcessedMatrix) (e.Row) (e.Row2) (e.RowToSub) (e.RowToSub2) t.Value t.CurrentRow t.CurrentColumn t.Ind <IsNegative (<Sub t.Ind t.CurrentRow>)>>;
	(e.ProcessedSystem) (e.ProcessedMatrix) (e.Row) (e.Row2) (e.RowToSub) (e.RowToSub2) t.Value t.CurrentRow t.CurrentColumn t.Ind '-'
		= (e.ProcessedSystem (e.Row)) (e.ProcessedMatrix (e.Row2));
	(e.ProcessedSystem) (e.ProcessedMatrix) (e.Row) (e.Row2) (e.RowToSub) (e.RowToSub2) t.Value t.CurrentRow t.CurrentColumn t.Ind s.Log
		= <SubRowWrapper (e.ProcessedSystem) (e.ProcessedMatrix) (e.Row) (e.Row2) (e.RowToSub) (e.RowToSub2) <CalcMultiplier <GetByIndex (e.Row) t.CurrentColumn> t.Value>>;
	(e.ProcessedSystem) (e.ProcessedMatrix) (e.Row) (e.Row2) (e.RowToSub) (e.RowToSub2) t.Multiplier
		= (e.ProcessedSystem <SubRow (e.Row) (e.RowToSub) t.Multiplier>) (e.ProcessedMatrix  <SubRow (e.Row2) (e.RowToSub2) t.Multiplier>);
}

SwapRows {
	(e.System) (e.Matrix) t.Row t.Row2 t.Index t.Index2
		= <ReplaceElement <ReplaceElement (e.System) <GetByIndex (e.System) t.Index2> t.Index> t.Row t.Index2>
			<ReplaceElement <ReplaceElement (e.Matrix) <GetByIndex (e.Matrix) t.Index2> t.Index> t.Row2 t.Index2>;
}

SubRows {
	(e.System) (e.Matrix) () t.CurrentRow t.CurrentColumn = (e.System) (e.Matrix) 'N';
	(e.System) (e.Matrix) (t.Value (t.Index)) t.CurrentRow t.CurrentColumn
		= <SubRows (e.System) (e.Matrix) (t.Value t.Index) t.CurrentRow t.CurrentColumn>;
	(e.System) (e.Matrix) (t.Value t.Index) t.CurrentRow t.CurrentColumn
		= <SubRows
			()
			()
			(e.System)
			(e.Matrix)
			(t.Value t.Index)
			<GetByIndex (e.System) t.Index>
			<GetByIndex (e.Matrix) t.Index>
			0
			t.CurrentRow
			t.CurrentColumn>;
	(e.ProcessedSystem) (e.ProcessedMatrix) (t.SystemRow e.System) (t.MatrixRow e.Matrix) (t.Value t.Index) t.Row t.Row2 t.Index t.CurrentRow t.CurrentColumn
		= <SubRows
			(e.ProcessedSystem t.SystemRow)
			(e.ProcessedMatrix t.MatrixRow)
		 	(e.System)
		 	(e.Matrix)
		 	(t.Value t.Index)
		 	t.Row
		 	t.Row2
		 	<Add t.Index 1>
		 	t.CurrentRow
		 	t.CurrentColumn>;
	(e.ProcessedSystem) (e.ProcessedMatrix) (t.SystemRow e.System) (t.MatrixRow e.Matrix) (t.Value t.Index) t.Row t.Row2 t.Ind t.CurrentRow t.CurrentColumn
		= <SubRows
			<SubRowWrapper (e.ProcessedSystem) (e.ProcessedMatrix) t.SystemRow t.MatrixRow t.Row t.Row2 t.Value t.CurrentRow t.CurrentColumn t.Ind>
			(e.System)
			(e.Matrix)
			(t.Value t.Index)
		 	t.Row
		 	t.Row2
		 	<Add t.Ind 1>
		 	t.CurrentRow
            t.CurrentColumn>;
	(e.ProcessedSystem) (e.ProcessedMatrix) () () (t.Value t.Index) t.Row t.Row2 t.Ind t.CurrentRow t.CurrentColumn
		= <SubRows <SwapRows (e.ProcessedSystem) (e.ProcessedMatrix) t.Row t.Row2 t.Index t.CurrentRow> t.CurrentRow t.CurrentColumn>;
	(e.ProcessedSystem) (e.ProcessedMatrix) t.CurrentRow t.CurrentColumn = (e.ProcessedSystem) (e.ProcessedMatrix);
}

MakeRowEchelonForColumn {
	(e.System) (e.Matrix) t.CurrentRow t.CurrentColumn = <MakeRowEchelonForColumn (e.System) (e.Matrix) <IsComplete (e.System) t.CurrentRow t.CurrentColumn> t.CurrentRow t.CurrentColumn>;
	(e.System) (e.Matrix) 'T' t.CurrentRow t.CurrentColumn = NonZero (e.System) (e.Matrix);
	(e.System) (e.Matrix) 'N' t.CurrentRow t.CurrentColumn = Zero (e.System) (e.Matrix);
	(e.System) (e.Matrix) 'F' t.CurrentRow t.CurrentColumn = <MakeRowEchelonForColumn <SubRows (e.System) (e.Matrix) <FindMin (e.System) t.CurrentRow t.CurrentColumn> t.CurrentRow t.CurrentColumn> t.CurrentRow t.CurrentColumn>;
}

/*вспомогательная функция к IsComplete*/
AddIfNotZero {
	t.First 0 = t.First;
	t.First (0) = t.First;
	t.First t.Second = <Add t.First 1>;
}

/*вспомогательная функция к IsComplete*/
CheckComplete {
	0 s.Log = 'N';
	(0) s.Log = 'N';
	1 '0' = 'F';
	(1) '0' = 'F';
	1 s.Log = 'T';
    (1) s.Log = 'T';
	t.Count s.Log = 'F';
}

SkipRows {
	(e.Eq) (t.CurrentRow) = <SkipRows (e.Eq) t.CurrentRow>;
	(e.Eq) t.CurrentRow = <SkipRows (e.Eq) t.CurrentRow 0>;
	(e.Eq) t.CurrentRow t.CurrentRow = (e.Eq);
	(t.Any e.Eq) t.CurrentRow t.Count = <SkipRows (e.Eq) t.CurrentRow <Add t.Count 1>>;
}

/*проверка, закончили ли мы с этим столбцом*/
IsComplete {
	(e.Eq) t.CurrentRow t.CurrentColumn =
		<IsComplete
			Skipped
			<SkipRows (e.Eq) t.CurrentRow>
			t.CurrentColumn>;
	Skipped (t.Any e.Eq) t.CurrentColumn = <IsComplete Started (t.Any e.Eq) t.CurrentColumn <IsNegative <GetByIndex t.Any t.CurrentColumn>> 0>;
	Started (t.Any e.Eq) t.CurrentColumn s.Log t.Count =
		<IsComplete
			Started
			(e.Eq)
			t.CurrentColumn
			s.Log
			<AddIfNotZero t.Count <GetByIndex t.Any t.CurrentColumn>>>;
	Started () t.CurrentColumn s.Log t.Count = <CheckComplete t.Count s.Log>;
}

MakeRowEchelon {
	() () = () ();
	(e.System) (e.Matrix)  = <MakeRowEchelon (e.System) (e.Matrix) 0 0 <RowsQty (e.System)> <ColumnsQty (e.System)>>;
	(e.System) (e.Matrix) t.CurrentRow t.CurrentColumn t.Rows t.CurrentColumn = (e.System) (e.Matrix);
	(e.System) (e.Matrix) t.CurrentRow t.CurrentColumn t.CurrentRow t.Columns = (e.System) (e.Matrix);
	(e.System) (e.Matrix) t.CurrentRow t.CurrentColumn t.Rows t.Columns = <MakeRowEchelon (e.System) (e.Matrix) t.CurrentRow t.CurrentColumn t.Rows t.Columns <MakeRowEchelonForColumn (e.System) (e.Matrix) t.CurrentRow t.CurrentColumn>>;
	(e.System) (e.Matrix) t.CurrentRow t.CurrentColumn t.Rows t.Columns Zero (e.NewSystem) (e.NewMatrix) = <MakeRowEchelon (e.NewSystem) (e.NewMatrix) t.CurrentRow <Add t.CurrentColumn 1> t.Rows t.Columns>;
	(e.System) (e.Matrix) t.CurrentRow t.CurrentColumn t.Rows t.Columns NonZero (e.NewSystem) (e.NewMatrix) = <MakeRowEchelon (e.NewSystem) (e.NewMatrix) <Add t.CurrentRow 1> <Add t.CurrentColumn 1> t.Rows t.Columns>;
}

RowsQty {
	(e.System) = <RowsQty Started (e.System) 0>;
	Started ((e.Eq) e.System) t.Count = <RowsQty Started (e.System) <Add t.Count 1>>;
	Started () t.Count = t.Count;
}

ColumnsQty {
	((e.Eq) e.System) = <ColumnsQty Started (e.Eq) 0>;
	Started (t.Any e.Rest) t.Count = <ColumnsQty Started (e.Rest) <Add t.Count 1>>;
	Started () t.Count = t.Count;
}

/*получение транспонированного ряда*/
MakeTransponentRowMatrix {
	(e.Truncated) (e.Result) ((t.Count) e.Rest) = <MakeTransponentRowMatrix (e.Truncated) (e.Result t.Count) (e.Rest)>;
	(e.Truncated) (e.Result) ((t.Count e.Eq) e.Rest) = <MakeTransponentRowMatrix (e.Truncated (e.Eq)) (e.Result t.Count) (e.Rest)>;
	(e.Truncated) (e.Result) () = (e.Truncated) (e.Result);
}

/*получение матрицы из системы уравнений*/
TransposeMatrix {
	() () = ();
	(e.Result) (e.System) = <TransposeMatrix () <MakeTransponentRowMatrix () () (e.System)>>;
	(e.Result) () (e.Row) = (e.Result (e.Row));
	(e.Result) (e.System) (e.Row) = <TransposeMatrix (e.Result (e.Row)) <MakeTransponentRowMatrix () () (e.System)>>;
}

LetterByInd {
	(e.List) (t.Count) = <LetterByInd (e.List) t.Count 0>;
	(e.List) t.Count = <LetterByInd (e.List) t.Count 0>;
	(s.A e.Rest) t.Count t.Count = s.A;
	(s.A e.Rest) t.Count t.Current = <LetterByInd (e.Rest) t.Count <Add t.Current 1>>;
}

BuildK {
	(t.Size) = <BuildK () 0 t.Size>;
	t.Size = <BuildK () 0 t.Size>;
	(e.Result) t.Size t.Size = (e.Result);
	(e.Result) t.Count t.Size = <BuildK (e.Result (<LetterByInd (<AlphabetT>) t.Count>)) <Add t.Count 1> t.Size>;

}

AddToKOrStop {
	(e.Processed) (e.Left) s.Var 0 t.Value = (e.Processed (s.Var) e.Left);
	(e.Processed) (e.Left) s.Var (0) t.Value = (e.Processed (s.Var) e.Left);
	(e.Processed) (e.Left) s.Var t.C t.Value = <AddToKOrStop (e.Processed) (e.Left) s.Var t.C t.Value <ModUnwrap t.Value t.C>>;
	(e.Processed) (e.Left) s.Var t.C t.Value (0) = (e.Processed (s.Var <DivUnwrap t.Value t.C>) e.Left);
	(e.Processed) (e.Left) s.Var t.C t.Value 0 = (e.Processed (s.Var <DivUnwrap t.Value t.C>) e.Left);
	(e.Processed) (e.Left) s.Var t.C t.Value t.Any = False;
}

CalculateK {
	() (e.Processed) () 0 = (e.Processed);
	() (e.Processed) () (0) = (e.Processed);
	() (e.Processed) () t.Any = False;
	(t.C e.Row) (e.Processed) ((s.Var t.C2) e.K) t.Value = <CalculateK (e.Row) (e.Processed (s.Var t.C2)) (e.K) <SubUnwrap t.Value <MulUnwrap t.C t.C2>>>;
	(t.C e.Row) (e.Processed) ((s.Var) e.K) t.Value = <AddToKOrStop (e.Processed) (e.K) s.Var t.C t.Value>;
}

FindK {
	() (e.RHS) = ();
	(e.Matrix) (e.RHS) = <FindK (e.Matrix) (e.RHS) <BuildK <ColumnsQty (e.Matrix)>>>;
	((e.Row) e.Matrix) (t.Value e.RHS) (e.K) = <FindK (e.Matrix) (e.RHS) <CalculateK (e.Row) () (e.K) t.Value>>;
	(e.Matrix) (e.RHS) False = False;
	() (e.RHS) (e.K) = (e.K);
}

ChooseK {
	(e.Matrix) False = False;
	(e.Matrix) (e.K) = (e.Matrix) (e.K);
}

IsNegative {
	('-' t.Value) = '-';
	0 = '0';
	(0) = '0';
	t.Value = '+';
}

MultiplyRowColumn {
	(e.Row) (e.K) = <MultiplyRowColumn (e.Row) (e.K) ((Const (0)))>;
	() () ((Const t.Value) e.Result) = ((Const t.Value) e.Result);
	(t.A e.Row) ((s.Name) e.K) (e.Result) = <MultiplyRowColumn (e.Row) (e.K) (e.Result (s.Name t.A))>;
	(t.A e.Row) ((s.Name t.K) e.K) ((Const t.Value) e.Result) = <MultiplyRowColumn (e.Row) (e.K) ((Const <AddUnwrap t.Value <MulUnwrap t.A t.K>>) e.Result)>;
}

CheckSolutions {
	(e.List) = <CheckSolutions () (e.List)>;
	(e.Result) () = (e.Result);
	(e.Result) (((Const ('-' t.Any))) e.List) = False;
	(e.Result) (t.Any e.List) = <CheckSolutions (e.Result t.Any) (e.List)>;
}

FilterSolutions {
	(e.List) = <FilterSolutions () (e.List)>;
	(e.Result) ((s.Name ('U')) e.Rest) = <FilterSolutions (e.Result) (e.Rest)>;
	(e.Result) ((s.Name (t.Value '-')) e.Rest) = False;
	(e.Result) ((s.Name (t.Value s.Log)) e.Rest) = <FilterSolutions (e.Result (s.Name t.Value)) (e.Rest)>;
	(e.Result) () = (e.Result);
}

CalcSolution {
	() () () = ();
	((e.Row) e.Matrix) (((var 'e' s.Name) e.Any) e.AllVars) (e.K) = <CalcSolution () (e.Matrix) (e.AllVars) (e.K) s.Name <MultiplyRowColumn (e.Row) (e.K)>>;
	(e.Result) ((e.Row) e.Matrix) (((var 'e' s.Name2) e.Any) e.AllVars) (e.K) s.Name t.Value = <CalcSolution (e.Result (s.Name t.Value)) (e.Matrix) (e.AllVars) (e.K) s.Name2 <MultiplyRowColumn (e.Row) (e.K)>>;
	(e.Result) () () (e.K) s.Name t.Value = <CheckSolutions (e.Result (s.Name t.Value))>;
}

FindInSolution {
	((s.Name t.Any) e.Solution) s.Name = t.Any;
	((s.Name2 t.Any) e.Solution) s.Name = <FindInSolution (e.Solution) s.Name>;
	() s.Name = ();
}

GenerateLetterVars {
	(t.Count) (s.x1 s.x2 s.x3 s.x4 s.x5) = <GenerateLetterVars t.Count (s.x1 s.x2 s.x3 s.x4 s.x5)>;
	t.Count (s.x1 s.x2 s.x3 s.x4 s.x5) = <GenerateLetterVars () (s.x1 s.x2 s.x3 s.x4 s.x5) t.Count 0>;
	(e.Result) (s.x1 s.x2 s.x3 s.x4 s.x5) t.Count t.Count = (e.Result) (s.x1 s.x2 s.x3 s.x4 s.x5);
	(e.Result) (s.x1 s.x2 s.x3 s.x4 s.x5) t.Count t.Current = <GenerateLetterVars (e.Result (var 't' s.x1 s.x2 s.x3 s.x4 s.x5)) (<NextNameT s.x1 s.x2 s.x3 s.x4 s.x5>) t.Count <Add t.Current 1>>;
}

FindUnusedVar {
	(e.System) = <FindUnusedVar (e.System) (<AlphabetT>)>;
	(e.System) (s.Sym e.Rest) = <FindUnusedVar (e.System) (s.Sym e.Rest) <IsUsedVar (e.System) s.Sym>>;
	(e.System) (s.Sym e.Rest) 'F' = s.Sym;
	(e.System) (s.Sym e.Rest) 'T' = <FindUnusedVar (e.System) (e.Rest)>;
}

IsUsedVar {
	() s.Sym = 'F';
	((t.Tag ()()) e.System) s.Sym = <IsUsedVar (e.System) s.Sym>;
	((t.Tag ((var 'e' s.Sym) e.LHS)(e.RHS)) e.System) s.Sym = 'T';
	((t.Tag (e.LHS)((var 'e' s.Sym) e.RHS)) e.System) s.Sym = 'T';
	((t.Tag (t.Any e.LHS)(e.RHS)) e.System) s.Sym = <IsUsedVar ((t.Tag (e.LHS)(e.RHS)) e.System) s.Sym>;
	((t.Tag (e.LHS)(t.Any e.RHS)) e.System) s.Sym = <IsUsedVar ((t.Tag (e.LHS)(e.RHS)) e.System) s.Sym>;
	((t.Tag (s.Any e.LHS)(e.RHS)) e.System) s.Sym = <IsUsedVar ((t.Tag (e.LHS)(e.RHS)) e.System) s.Sym>;
	((t.Tag (e.LHS)(s.Any e.RHS)) e.System) s.Sym = <IsUsedVar ((t.Tag (e.LHS)(e.RHS)) e.System) s.Sym>;
    ((t.Tag (s.Any e.LHS)(s.Any2 e.RHS)) e.System) s.Sym = <IsUsedVar ((t.Tag (e.LHS)(e.RHS)) e.System) s.Sym>;
	((t.Tag (t.Any e.LHS)(t.Any2 e.RHS)) e.System) s.Sym = <IsUsedVar ((t.Tag (e.LHS)(e.RHS)) e.System) s.Sym>;
}

SubSolutions {
	t.First t.Second = <SubSolutions () t.First t.Second>;
	(e.Result) () () = (e.Result);
	(e.Result) ((Const t.Value) e.List) ((Const t.Value2) e.List2) = <SubSolutions ((Const <SubUnwrap t.Value t.Value2>)) (e.List) (e.List2)>;
	(e.Result) ((s.Name t.Value) e.List) ((s.Name t.Value2) e.List2) = <SubSolutions (e.Result (s.Name <SubUnwrap t.Value t.Value2>)) (e.List) (e.List2)>;
}

FirstReplaceDifferent {
	(e.Generated) (e.System) s.Name s.Name2 (s.x1 s.x2 s.x3 s.x4 s.x5) = <FirstReplaceDifferent (e.Generated) (e.System) s.Name s.Name2 (s.x1 s.x2 s.x3 s.x4 s.x5) <FindUnusedVar (e.Generated e.System)>>;
	(e.Generated) (e.System) s.Name s.Name2 (s.x1 s.x2 s.x3 s.x4 s.x5) s.NextName
		= <DiophantineSolve (
			<Sim () <subst_2 (assign (var 'e' s.Name)((var 'e' s.Name2)(var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(var 'e' s.NextName))) e.Generated>>
			 (Generated ((var 'e' s.Name))((var 'e' s.Name2)(var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(var 'e' s.NextName)))
			 <Sim () <subst_2 (assign (var 'e' s.Name)((var 'e' s.Name2)(var 't' s.x1 s.x2 s.x3 s.x4 s.x5)(var 'e' s.NextName))) e.System>>)>;
}

FirstReplace {
	(e.Generated) (e.System) s.Name s.Name2 (e.Solution) (s.x1 s.x2 s.x3 s.x4 s.x5)
		= <FirstReplace Started (e.Generated) (e.System) s.Name s.Name2 (e.Solution) <TruncateSolution <SubSolutions <FindInSolution (e.Solution) s.Name> <FindInSolution (e.Solution) s.Name2>>> (s.x1 s.x2 s.x3 s.x4 s.x5)>;
	Started (e.Generated) (e.System) s.Name s.Name2 (e.Solution) 'F' (s.x1 s.x2 s.x3 s.x4 s.x5) = e.Generated e.System;
	Started (e.Generated) (e.System) s.Name s.Name2 (e.Solution) t.Count (s.x1 s.x2 s.x3 s.x4 s.x5)
		= <FirstReplace Correct (e.Generated) (e.System) s.Name s.Name2 (e.Solution) <IsNegative t.Count> (s.x1 s.x2 s.x3 s.x4 s.x5)>;
	Correct (e.Generated) (e.System) s.Name s.Name2 (e.Solution) '-' (s.x1 s.x2 s.x3 s.x4 s.x5)
		= <FirstReplaceDifferent (e.Generated) (e.System) s.Name2 s.Name (s.x1 s.x2 s.x3 s.x4 s.x5)>;
	Correct (e.Generated) (e.System) s.Name s.Name2 (e.Solution) '0' (s.x1 s.x2 s.x3 s.x4 s.x5)
		= <Sim () <subst_2 (assign (var 'e' s.Name2)((var 'e' s.Name))) e.Generated >> (Generated ((var 'e' s.Name2))((var 'e' s.Name))) <Sim () <subst_2 (assign (var 'e' s.Name2)((var 'e' s.Name))) e.System>>;
	Correct (e.Generated) (e.System) s.Name s.Name2 (e.Solution) '+' (s.x1 s.x2 s.x3 s.x4 s.x5)
		= <FirstReplaceDifferent (e.Generated) (e.System) s.Name s.Name2 (s.x1 s.x2 s.x3 s.x4 s.x5)>;
}

HasConstSymbol {
	() = 'F';
	(s.Sym e.Rest) = 'T';
	(t.Any e.Rest) = <HasConstSymbol (e.Rest)>
}

FirstReplaceSingle {
	(e.Generated) (e.System) s.Name s.Name2 (s.x1 s.x2 s.x3 s.x4 s.x5) 'F' = e.Generated e.System;
	(e.Generated) (e.System) s.Name s.Name2 (s.x1 s.x2 s.x3 s.x4 s.x5) 'T' = <FirstReplaceDifferent (e.Generated) (e.System) s.Name s.Name2 (s.x1 s.x2 s.x3 s.x4 s.x5)>;
}

TryFirstReplace {
	() () (e.Solution) (s.x1 s.x2 s.x3 s.x4 s.x5) = ;
	(e.Generated) (t.First e.System) (e.Solution) (s.x1 s.x2 s.x3 s.x4 s.x5)
	 	= <TryFirstReplace Started (e.Generated) (e.System) t.First (e.Solution) (s.x1 s.x2 s.x3 s.x4 s.x5)>;
	Started (e.Generated) (e.System) (t.Tag ((var 'e' s.Name) e.LHS)((var 'e' s.Name2) e.RHS)) (e.Solution) (s.x1 s.x2 s.x3 s.x4 s.x5)
		= <TryFirstReplace
				Started
				(e.Generated)
				((t.Tag ((var 'e' s.Name) e.LHS)((var 'e' s.Name2) e.RHS)) e.System)
				(e.Solution)
				<TruncateSolution <SubSolutions <FindInSolution (e.Solution) s.Name> <FindInSolution (e.Solution) s.Name2>>>
				(s.x1 s.x2 s.x3 s.x4 s.x5)>;
	/*точно отношения нет, но правая часть состоит ровно из одной переменной*/
	Started (e.Generated) ((t.Tag ((var 'e' s.Name))((var 'e' s.Name2) e.RHS)) e.System) (e.Solution) 'F' (s.x1 s.x2 s.x3 s.x4 s.x5)
		= <FirstReplaceSingle
			(e.Generated)
			((t.Tag ((var 'e' s.Name))((var 'e' s.Name2) e.RHS)) e.System)
			s.Name
			s.Name2
			(s.x1 s.x2 s.x3 s.x4 s.x5)
			<HasConstSymbol (e.RHS)>>;
	/*точно отношения нет, но левая часть состоит ровно из одной переменной*/
	Started (e.Generated) ((t.Tag ((var 'e' s.Name) e.LHS)((var 'e' s.Name2))) e.System) (e.Solution) 'F' (s.x1 s.x2 s.x3 s.x4 s.x5)
		= <FirstReplaceSingle
			(e.Generated)
			((t.Tag ((var 'e' s.Name) e.LHS)((var 'e' s.Name2))) e.System)
			s.Name2
			s.Name
			(s.x1 s.x2 s.x3 s.x4 s.x5)
			<HasConstSymbol (e.LHS)>>;
	/*точно отношения нет*/
	Started (e.Generated) ((t.Tag ((var 'e' s.Name) e.LHS)((var 'e' s.Name2) e.RHS)) e.System) (e.Solution) 'F' (s.x1 s.x2 s.x3 s.x4 s.x5)
		= e.Generated (t.Tag ((var 'e' s.Name) e.LHS)((var 'e' s.Name2) e.RHS)) e.System;
	/*есть точное отношение*/
	Started (e.Generated) ((t.Tag ((var 'e' s.Name) e.LHS)((var 'e' s.Name2) e.RHS)) e.System) (e.Solution) t.Count (s.x1 s.x2 s.x3 s.x4 s.x5)
		= <FirstReplace
			Started
			(e.Generated)
			((t.Tag ((var 'e' s.Name) e.LHS)((var 'e' s.Name2) e.RHS)) e.System)
			s.Name
			s.Name2
			(e.Solution)
			t.Count
			(s.x1 s.x2 s.x3 s.x4 s.x5)>;
	/*одна из частей уравнения (или обе) не начинаются с переменной*/
	Started (e.Generated) (e.System) (t.Tag (e.LHS)(e.RHS)) (e.Solution) (s.x1 s.x2 s.x3 s.x4 s.x5) = e.Generated (t.Tag (e.LHS)(e.RHS)) e.System;
}

ReplaceSingle {
	(e.Generated) (e.System) s.Name (0) (s.x1 s.x2 s.x3 s.x4 s.x5) = <ReplaceSingle (e.Generated) (e.System) s.Name 0 (s.x1 s.x2 s.x3 s.x4 s.x5)>;
	(e.Generated) (e.System) s.Name 0 (s.x1 s.x2 s.x3 s.x4 s.x5) = (<Sim () <subst_2 (assign (var 'e' s.Name)()) e.Generated>> (Generated ((var 'e' s.Name))())) (<Sim () <subst_2 (assign (var 'e' s.Name)()) e.System>>) (s.x1 s.x2 s.x3 s.x4 s.x5);
	(e.Generated) (e.System) s.Name t.Count (s.x1 s.x2 s.x3 s.x4 s.x5) = <ReplaceSingle RE (e.Generated) (e.System) s.Name <GenerateLetterVars t.Count (s.x1 s.x2 s.x3 s.x4 s.x5)>>;
	RE (e.Generated) (e.System) s.Name (e.List) (s.x1 s.x2 s.x3 s.x4 s.x5) = (<Sim () <subst_2 (assign (var 'e' s.Name)(e.List)) e.Generated>> (Generated ((var 'e' s.Name))(e.List))) ( <Sim () <subst_2 (assign (var 'e' s.Name)(e.List)) e.System>>) (s.x1 s.x2 s.x3 s.x4 s.x5);
}

TruncateSolution {
	((Const t.Count)) = t.Count;
	((Const t.Count) (s.Name 0) e.List) = <TruncateSolution ((Const t.Count) e.List)>;
	((Const t.Count) (s.Name (0)) e.List) = <TruncateSolution ((Const t.Count) e.List)>;
	((Const t.Count) e.List) = 'F';
}

TryReplaceSingle {
	(e.Generated) (e.System) s.Name t.Solution (s.x1 s.x2 s.x3 s.x4 s.x5) = <TryReplaceSingle Replace (e.Generated) (e.System) s.Name <TruncateSolution t.Solution> (s.x1 s.x2 s.x3 s.x4 s.x5)>;
	Replace (e.Generated) (e.System) s.Name 'F' (s.x1 s.x2 s.x3 s.x4 s.x5) = (e.Generated) (e.System) (s.x1 s.x2 s.x3 s.x4 s.x5);
	Replace (e.Generated) (e.System) s.Name t.Value (s.x1 s.x2 s.x3 s.x4 s.x5) = <ReplaceSingle (e.Generated) (e.System) s.Name t.Value (s.x1 s.x2 s.x3 s.x4 s.x5)>;
}

ApplySolution {
	(e.Generated) (e.System) () = e.Generated e.System;
	(e.Generated) (e.System) (e.Solution) = <ApplySolution (e.Generated) (e.Solution) (e.System) (<NextNameT <FindMaxNameT () e.Generated e.System>>)>;
	(e.Generated) (e.Solution) (e.System) (s.x1 s.x2 s.x3 s.x4 s.x5) = <ApplySolution Replace () (e.Solution) (e.Generated) (e.System) (s.x1 s.x2 s.x3 s.x4 s.x5)>;
	Replace (e.Processed) ((s.Name t.Any) e.Solution) (e.Generated) (e.System) (s.x1 s.x2 s.x3 s.x4 s.x5) = <ApplySolution Replace (e.Processed (s.Name t.Any)) (e.Solution) <TryReplaceSingle (e.Generated) (e.System) s.Name t.Any (s.x1 s.x2 s.x3 s.x4 s.x5)>>;
	Replace (e.Processed) () (e.Generated) (e.System) (s.x1 s.x2 s.x3 s.x4 s.x5) = <ApplySolution First (e.Processed) (e.Generated) (e.System) (s.x1 s.x2 s.x3 s.x4 s.x5)>;
	First (e.Solution) (e.Generated) (e.System) (s.x1 s.x2 s.x3 s.x4 s.x5) = <TryFirstReplace (e.Generated) (e.System) (e.Solution) (s.x1 s.x2 s.x3 s.x4 s.x5)>;
}

IsTVarValid {
	() (s.x1 s.x2 s.x3 s.x4 s.x5) s.Sym = ;
	((t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))(s.Sym)) e.Set) (s.x1 s.x2 s.x3 s.x4 s.x5) s.Sym = <IsTVarValid (e.Set) (s.x1 s.x2 s.x3 s.x4 s.x5) s.Sym>;
	((t.Tag (s.Sym)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))) e.Set) (s.x1 s.x2 s.x3 s.x4 s.x5) s.Sym = <IsTVarValid (e.Set) (s.x1 s.x2 s.x3 s.x4 s.x5) s.Sym>;
	((t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))(s.Sym2)) e.Set) (s.x1 s.x2 s.x3 s.x4 s.x5) s.Sym = False;
	((t.Tag (s.Sym2)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))) e.Set) (s.x1 s.x2 s.x3 s.x4 s.x5) s.Sym = False;
	(t.Eq e.Set) (s.x1 s.x2 s.x3 s.x4 s.x5) s.Sym = <IsTVarValid (e.Set) (s.x1 s.x2 s.x3 s.x4 s.x5) s.Sym>;
}

CheckTVars {
	() = ;
	((t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))(s.Sym)) e.Set) = <CheckTVars (e.Set) <IsTVarValid (e.Set) (s.x1 s.x2 s.x3 s.x4 s.x5) s.Sym>>;
	((t.Tag (s.Sym)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))) e.Set) = <CheckTVars (e.Set) <IsTVarValid (e.Set) (s.x1 s.x2 s.x3 s.x4 s.x5) s.Sym>>;
	(e.Set) False = False;
}

ReplaceTVar {
	(e.Set) (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 't' s.x6 s.x7 s.x8 s.x9 s.x10) = <ReplaceTVar () (e.Set) (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 't' s.x6 s.x7 s.x8 s.x9 s.x10)>;
	(e.Processed) ((t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))(s.Sym)) e.Set) (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 't' s.x6 s.x7 s.x8 s.x9 s.x10) = <ReplaceTVar (e.Processed (t.Tag ((var 't' s.x6 s.x7 s.x8 s.x9 s.x10))(s.Sym))) (e.Set) (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 't' s.x6 s.x7 s.x8 s.x9 s.x10)>;
	(e.Processed) ((t.Tag (s.Sym)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))) e.Set) (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 't' s.x6 s.x7 s.x8 s.x9 s.x10) = <ReplaceTVar (e.Processed (t.Tag (s.Sym)((var 't' s.x6 s.x7 s.x8 s.x9 s.x10)))) (e.Set) (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 't' s.x6 s.x7 s.x8 s.x9 s.x10)>;
	(e.Processed) ((t.Tag (e.LHS)(e.RHS)) e.Set) (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 't' s.x6 s.x7 s.x8 s.x9 s.x10) = <ReplaceTVar (e.Processed (t.Tag (e.LHS)(e.RHS))) (e.Set) (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 't' s.x6 s.x7 s.x8 s.x9 s.x10)>;
	(e.Processed) () (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 't' s.x6 s.x7 s.x8 s.x9 s.x10) = (e.Processed);
}

ReplaceTVars {
	(e.System) (e.Set) = <ReplaceTVars () (e.System) (e.Set)>;
	(e.Processed) ((t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5)) ((var 't' s.x6 s.x7 s.x8 s.x9 s.x10))) e.System) (e.Set)
		= <ReplaceTVars
			(e.Processed (t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5)) ((var 't' s.x6 s.x7 s.x8 s.x9 s.x10))))
			(e.System)
			<ReplaceTVar (e.Set) (var 't' s.x1 s.x2 s.x3 s.x4 s.x5) (var 't' s.x6 s.x7 s.x8 s.x9 s.x10)>>;
	(e.Processed) (t.Eq e.System) (e.Set) = <ReplaceTVars (e.Processed t.Eq) (e.System) (e.Set)>;
	(e.Processed) () (e.Set) = <CheckTVars (e.Set)>;
}

FindTVarsContradiction {
	(e.System) = <FindTVarsContradiction () (e.System) ()>;
	(e.Processed) ((t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))(s.Sym)) e.System) (e.Set)
		= <FindTVarsContradiction (e.Processed (t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))(s.Sym))) (e.System) (e.Set (t.Tag ((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))(s.Sym)))>;
	(e.Processed) ((t.Tag (s.Sym)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))) e.System) (e.Set)
		= <FindTVarsContradiction (e.Processed (t.Tag (s.Sym)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5)))) (e.System) (e.Set (t.Tag (s.Sym)((var 't' s.x1 s.x2 s.x3 s.x4 s.x5))))>;
	(e.Processed) (t.Eq e.System) (e.Set) = <FindTVarsContradiction (e.Processed t.Eq) (e.System) (e.Set)>;
	(e.Processed) () (e.Set) = <ReplaceTVars (e.Processed) (e.Set)>;
}
